{"title":"DP","uid":"25ed3aa3446c2c64cf6228f9f4e4f9c4","slug":"DP","date":"2021-09-16T09:38:51.000Z","updated":"2021-09-16T12:28:18.110Z","comments":true,"path":"api/articles/DP.json","keywords":null,"cover":null,"content":"<h1 id=\"DP\"><a href=\"#DP\" class=\"headerlink\" title=\"DP\"></a>DP</h1><h2 id=\"part1-动态规划的核心概念\"><a href=\"#part1-动态规划的核心概念\" class=\"headerlink\" title=\"part1.动态规划的核心概念\"></a>part1.动态规划的核心概念</h2><ul>\n<li>状态</li>\n<li>转移方程</li>\n<li>初始化</li>\n</ul>\n<h3 id=\"实例揭秘本质—斐波那契数列\"><a href=\"#实例揭秘本质—斐波那契数列\" class=\"headerlink\" title=\"实例揭秘本质—斐波那契数列\"></a>实例揭秘本质—斐波那契数列</h3><ul>\n<li>$众所周知 斐波那契数列的的递推式是:$ $f_i = f_{i-1} + f_{i-1}(i \\ge 2)$​</li>\n<li>$问题来了，如何来求$$f_n$?</li>\n<li>$这个时候就要用到f_i = f_{i-1} + f_{i-1}来得到他们的值，那么这个时候f_i,f_{i-1},f_{i-2}就对应$<strong>$动态规划$</strong>$里面的$<strong>$状态$</strong></li>\n<li>$所谓的$<strong>状态</strong>$就指的是你要求<script type=\"math/tex\">f_n$​，$那么我们有一些中间结果来得到最后的</script>f_n$​，$这些中间的结果，就叫做动态规划里面的$<strong>$状态$</strong></li>\n<li>$这些状态之间的关键就叫$<strong>$转移方程$</strong></li>\n<li>$最后一个概念$<strong>$状态的初始化$</strong>，$所谓的状态的初始化就是会存在$<strong>$部分状态无法通过转移方程$</strong>$求得，在斐波那契数列中$f_0 = 0,f_1 = 1$这个两个值是提前确定好的，如果没有这两个值，那么也不会有后面的值了$</li>\n<li>$所以解决一道普通的动态规划题，我们需要$<strong>$设计状态，求转移方程，初始化$</strong>$这三个步骤$</li>\n<li>$接下来我们来写一下斐波那契数列的代码来找一下其中的方法$<ul>\n<li>$在斐波那契数列中我们可以找出三种方法即:$<ul>\n<li><strong>$用别人求自己$</strong>(由$f_{i-1} + f_{i-2} \\to f_i$​)</li>\n<li><strong>$用自己求别人$</strong>$(由$f_i \\to $$\\begin{cases} f_{i+1} \\\\ f_{i+2}  \\end{cases}$​​​</li>\n<li><strong>$记忆化搜索$</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>$在某些题中我们只能用一种方法，因为这些题会利用这两种方法的一种性质$</li>\n</ul>\n<p>$Code:$</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;bits/stdc++.h></span></span>\n\n<span class=\"token keyword\">using</span> <span class=\"token keyword\">namespace</span> std<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token keyword\">int</span> maxn <span class=\"token operator\">=</span> <span class=\"token number\">2e6</span><span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> n<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> f<span class=\"token punctuation\">[</span>maxn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">int</span> tag<span class=\"token punctuation\">[</span>maxn<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">//记忆化搜索</span>\n<span class=\"token keyword\">void</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> n<span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>tag<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\ttag<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//tag[n]代表f[n]有没有被算过</span>\n\tf<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> f<span class=\"token punctuation\">[</span>n<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tf<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>f<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">//用别人求自己</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> \n\t\tf<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> f<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+</span> f<span class=\"token punctuation\">[</span>i<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">//用自己求别人</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>i <span class=\"token operator\">&lt;=</span> n<span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t\tf<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span>f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t\tf<span class=\"token punctuation\">[</span>i<span class=\"token operator\">+</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">+=</span>f<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">&#125;</span>\n\n\t<span class=\"token comment\">//记忆化搜索</span>\n\t<span class=\"token function\">dfs</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"Problem-1-组合数\"><a href=\"#Problem-1-组合数\" class=\"headerlink\" title=\"Problem 1:组合数\"></a>Problem 1:组合数</h3><ul>\n<li>$组合数是指从n个东西里面选m个东西的方案数，一般写作C_n^m$</li>\n<li>$给定n和m，求出C_n^m的值是多少$</li>\n<li>$在这个状态里有两种情况$</li>\n<li>$即要选最后一个东西和不选最后一个东西$</li>\n<li>$将两种情况相加即可得到最后的结果$</li>\n<li>$C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$</li>\n</ul>\n<h3 id=\"Problem-2\"><a href=\"#Problem-2\" class=\"headerlink\" title=\"Problem 2:\"></a>Problem 2:</h3><ul>\n<li>$N * M的方格图，只能向右或者向下，走到右下的方案数？走到右下的最小代价？$</li>\n<li>$1.$$方案数：$</li>\n<li>$用f[i][j]代表走到(i,j)这个位置的方案数$<ul>\n<li>$在这个问题中我们就要逐渐注意状态怎么来设计，在很多时候我们的题目要\\\\求什么我们的状态就要怎么来设计$</li>\n</ul>\n</li>\n<li>$所以这个问题的转移方程就是f(i,j) = f(i-1,j) + f(i,j-1)初始化为f(i,0) = f(0,j) = 1$</li>\n<li>$2.$$最小代价$</li>\n<li>$用f[i][j]表示现在走到(i,j)所需要的最小代价$</li>\n<li>$所以转移方程显然是f[i][j] = min(f[i-1][j],f[i][j-1]) + w[i][j]$</li>\n<li>$初始化和1.同$</li>\n</ul>\n<p><strong>$拓展$</strong><br>$如果要求不用dp，现在要求直接把走到(n,m)这个点的方案数用一个式子写出来应当是什么样？$</p>\n<p><em>$Solve$</em><br>$我们思考如果要从(0,0)走到(n,m)一共有多少步，显然我们需要走n+m步才能到达(n,m)，进而看出往下应该走n步,往右应该走m步，所以，我们可以得出最后的式子为C_{n}^{n+m}$</p>\n<h3 id=\"Problem-3\"><a href=\"#Problem-3\" class=\"headerlink\" title=\"$Problem 3$\"></a>$Problem 3$</h3><ul>\n<li>$数字三角形$<a href=\"https://www.luogu.com.cn/problem/P1216\">Luogu1216</a></li>\n<li>$给定一个三角形，让你从最顶上走到最下面$</li>\n<li>$问怎么走能够取得最大价值$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$设f[i][j]为走到(i,j)能取得的最大价值$</li>\n<li>$那么转移方程很显然是f[i][j] = max(f[i-1][j-1],f[i-1][j]) + w[i][j]$</li>\n</ul>\n<h3 id=\"Problem-4\"><a href=\"#Problem-4\" class=\"headerlink\" title=\"Problem 4\"></a>Problem 4</h3><ul>\n<li>$将上面的问题改成点权之和$\\% 100$之后最大    ，求最大价值$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li><p>$在这一题中，我们可以发现，按照以前的原则，\\\\题目问什么我们设什么已经不再好用了，在这题\\\\中我们如果设f(i,j)代表走到(i,j)和\\%$ $100$ $的最大值是多少的话，我们会遇到无法用f(i-1,j-1)和 f(i - 1,j)求出真正f(i,j)的值，也就是说这样记录的状态算出来的答\\\\案是错误的，所以我们不可以这么设计状态。$</p>\n</li>\n<li><p>$这时候我们引入一个新的方法，就是题目每多一个条件，我的状态就多一个维度,\\\\所以我们设f(i,j,k)为    走到(i,j)使得点权和(k)$$\\%$ $100 = k 是否可能$</p>\n</li>\n<li>$和上题一样从(i-1,j-1)或者(i-1,j)走到(i,j)$\\% 100$ $= k$</li>\n<li>$在走到(i,j)之前我们的k \\longleftarrow k - w_{i,j}$</li>\n<li>$所以我们的转移方程就是 \\\\ f[i][j][k] = f[i-1][j-1][k - w_{i,j}]\\ \\  ||\\ \\  f[i][j][k] = f[i-1][j][k - w_{i,j}]$</li>\n</ul>\n<h3 id=\"Problem-5\"><a href=\"#Problem-5\" class=\"headerlink\" title=\"Problem 5\"></a>Problem 5</h3><p>$1.最长上升子序列$</p>\n<ul>\n<li>$给n个数,a_1,a_2,\\cdots,a_n$</li>\n<li>$希望有 1 \\le b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_m \\le n$</li>\n<li>$使得a_{b_1} &lt; a_{b_2} &lt; a_{b_3} \\cdots &lt; a_{b_m}$ </li>\n<li>$即找到一个最长序列，使得这个数列一直在上升$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$观察目标，我们可以设f[i]代表我找出来的序列最后一个数为a_i时，序列最长能有多长$</li>\n<li>$考虑转移，显然我们需要考虑到a_i下一个数或者前一个数是谁，这样我们就可以得到 \\\\ f[i] = max_{i \\le j &lt; i\\ \\ \\  \\&amp;\\&amp; \\ \\ \\  a_j &lt; a_i}(f[j] + 1)$</li>\n<li>$这个转移的含义为:最后一位是a_i时，枚举一个j这就保证j &lt; i \\ \\ \\  \\&amp;\\&amp; \\ \\ \\ a_j &lt; a_i，满足了这两个条件，那么我们再补一个a_i就使它的长度+1，对于所有的j取一个最大值，我们就可以算出f(i)的值了，时间复杂度O(n^2)$</li>\n<li>$这个时间复杂度显然不优，这个时候我们可以用到数据结构优化dp来做$</li>\n<li>$a_1,a_2,a_3,\\cdots,a_n$，$设里面的最小值为1，最大值为m$</li>\n<li>我们可以建一颗$1 ~ m$的线段树</li>\n<li>$这个时候我们可以设a_1作为结尾的最长长度为f[1]，a_2作为结尾的最长长度为f[2]， \\\\ \\cdots,以此类推$</li>\n<li>$假设现在到了i,我们要算以i为结尾的最长长度，那么我们就要从a_i 到 a_{i-1}中选出a_j\\\\ ，使得a_j &lt; a_i并且这个f[j]是最大的$</li>\n<li>$将a_1 到 a_{i-1}存到f_1 到 f_{i-1}$</li>\n<li>$我现在要询问a_i的值就是在1 \\le f_i \\le a_i找到f_i的最大值$</li>\n<li>$这样这个问题就转化为了一个查询区间最大值的线段树，这个区间就是1$ ~ $a_i - 1$ $这个区间就是包含了所有&lt; a_i的数，也很容易得到a_i对应的为f_i+1$</li>\n</ul>\n<p><strong>$2.求方案$</strong></p>\n<ul>\n<li>$根据上面的问题我们再换成求最长上升子序列的方案</li>\n</ul>\n<p><strong>$Solve$</strong><br>$所有求方案的DP基本上都是一个套路$<br>$下面用这个题来解决求方案的问题$</p>\n<ul>\n<li>$对于这个问题，我们除了要记录原来题目中的状态之外，还需要设一个pre[i],\\\\ 来记录是从哪个状态转移过来的$</li>\n<li>$例如，pre[10] = 7代表的含义就是f[10]这个位置的状态是从f[7]转移过来的，那么我们可以接着设$</li>\n<li>$pre[7]=5，pre[5]=2,pre[2]=1 ，我们这样就可以倒着走遍历出来最优方案，\\\\最后的方案就是a_1,a_2,a_5,a_7,a_{10}这个序列$</li>\n</ul>\n<h3 id=\"Problem-6\"><a href=\"#Problem-6\" class=\"headerlink\" title=\"Problem 6\"></a>Problem 6</h3><p>$滑雪$</p>\n<ul>\n<li>$n行m列的图$</li>\n<li>$每个格子有高度$</li>\n<li>$可以滑向周围四个比自己矮的格子$</li>\n<li>$最多能划多远$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<p>$这个问题和迷宫很不一样，迷宫是给定了起点，而这个题目是让你自己选择起点$<br>$通过观察我们可以发现，我们可以将原图按照从大到小或者从小到大排一遍序$<br>$然后我设f(r)为以r为重点最远可以走多远$<br>$现在，我们把问题转化成了一个最长下降子序列，现在转移方程就很显然了<script type=\"math/tex\">$f[r] = max_{1 \\le k < r，第r个格子和第k个格子相邻}(f[k])+1</script></p>\n<h3 id=\"Problem-7\"><a href=\"#Problem-7\" class=\"headerlink\" title=\"Problem 7\"></a>Problem 7</h3><p><strong>$乌龟棋$</strong></p>\n<ul>\n<li>$长度为n的格子有权值$</li>\n<li>$m张牌，上面有1-4中其中一个数$</li>\n<li>$使用一张牌往前走几步$</li>\n<li>$最大化经过的路径权值和$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$我们设f[i]为走到了i这个位置,但是我们会发现,无法判断牌被用了多少张,\\\\也就是说会出现越界,所以我们需要再多加几维状态：设f[i][a][b][c][d]为走\\\\到i这个位置时，1牌被用了a张，2牌被用了b张，3牌被用了c张，4牌被用了d张$</li>\n<li>$思考复杂度，这个复杂度是O(nm_1m_2m_3m_4) \\approx O(n^5)显然是过不了的$</li>\n<li>$在Problem5中我们讲解了数据结构优化dp,在这里我们讲解另外一种优\\\\化dp的方式$<strong>$冗余状态优化$</strong></li>\n<li>$观察状态设计,我们通过简单的推出一个式子$$$i = a+2b+3c+4d$$$所以这五维状态我们任意删除一个状态即可,这样我们就把时间复杂度\\\\由O(n^5)优化到了O(m^4)了$</li>\n</ul>\n<h2 id=\"区间DP\"><a href=\"#区间DP\" class=\"headerlink\" title=\"区间DP\"></a>区间DP</h2><ul>\n<li>$以区间作为dp的状态，每次区间[l,r]$</li>\n<li>$即设f(i,j)表示区间[i，r]的最优解$</li>\n</ul>\n<p><strong>$Problem1$</strong></p>\n<p>$合并石子$</p>\n<ul>\n<li>$有n堆石子,a_1,a_2,a_3,\\cdots,a_n$</li>\n<li>$需要做n-1次操作，每次操作需要合并相邻两对石子$</li>\n<li>$例如,合并a_2和a_3就是a_2 + a_3然后就变成了n-1堆石子a_1,a_2+a_3,\\cdots,a_n，且合并\\\\这两堆石子的代价为a_2+a_3$</li>\n<li>$现在希望你合并出来a_1+a_2+a_3+\\cdots+a_n，并且最小代价是多少$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$这道题是典型的区间dp题,当你看到有相邻的操作的时候，我们首先就要考虑区间dp。$</li>\n<li>$首先很容易想到的一个性质就是，如果a_l,a_r被合并了，那么a_l,a_{l+1},\\cdots,a_{r-1},a_r \\\\都被合并$</li>\n<li>$想到了如下性质之后我们来讲一下关于区间dp的三要素$<ul>\n<li>$状态：一般设计成f[l][r] 代表把第l$ ~ $r 合并为\\cdots$</li>\n<li>$转移：思考f[l][r]怎么求，在合并l$ ~ $r的前一次操作是把l$ ~ $k$和$k+1$ ~ $r<script type=\"math/tex\">的合并成一堆$，$那么合并成这两堆石子的代价分别是，f[l][k]和f[k+1][r]，\\\\所以这个转移方程是$ </script>f[l][r] = min_{l \\le k \\le r}(f[l][r],f[l][k] + f[k+1][r] + sum[r] - sum[l-1])$$</li>\n<li>$初始化：首先肯定要让i \\rightarrow i 花费的代价为0，故f[i][i] = 0$</li>\n</ul>\n</li>\n</ul>\n<p><strong>$Problem2$</strong></p>\n<ul>\n<li>$n个矩阵$</li>\n<li>$m_1:a_1 \\times a_2，m_2:a_2 \\times a_3，m_3: a_3 \\times a_4,\\cdots,m_n:a_n \\times a_{n+1}$</li>\n<li>$把n个矩阵乘起来，可以进行结合律，计算m_2和m_3这两个矩阵的代价是a_2 \\times a_3 \\times a_4，随后这两个矩阵变成(m_2 \\times m_3):a_2 \\times a_4$</li>\n<li>$现在的问题是，把这些矩阵加一些括号，使这些矩阵代价最小$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$基于上一题的思想，我们可以设f[l][r]为将m_l$ ~ $m_r这些矩阵乘起来所需要的最小代价$</li>\n<li>$枚举一个中间的断点k，把a_l$ ~ $a_k和a_{k+1}$ ~ $a_r分别算出，最后把这两个矩阵乘起来即可$</li>\n<li>$所以这个转移方程就是<script type=\"math/tex\">$f[l][r] = min_{l \\le k < r}(f[l][k] + f[k+1][r] + a[l] * a[k+1] * a[r+1])</script></li>\n<li>$所以这一题我们也用区间dp搞定了$</li>\n</ul>\n<p><strong>$Problem3$</strong></p>\n<ul>\n<li>$给出一个的只有()[]四种括号组成的字符串$</li>\n<li>$求出最多能够选出多少个括号满足完全匹配$</li>\n</ul>\n<p><strong>$Solve$</strong></p>\n<ul>\n<li>$这个题的转移方法和上面的不太一样，我们设f[l][r]代表从l - r最多能取出多少个括号进行匹配$</li>\n<li>$思考f[l][r]和f[l+1][r]的关系,例如f[l+1][r]我们可以取10个括号进行匹配，那么f[l][r]也可以取十个括号$</li>\n<li>$同理，如果f[l][r-1]取了12个括号，那f[l][r]也可以取12个括号$</li>\n<li>$所以f[l][r] = max(f[l][r] || f[l][r-1])$</li>\n<li>$思考还有没有其他的情况，显然还有一种情况是如果l - r为:(()),1-4这四个括号可以选4个括号,因为除了在l - r-1和l+1 - r这两个区间内部以外，还有一种方案是从l+1 - r-1，在l和r匹配相同的括号，再在l+1 - r-1中匹配括号$</li>\n<li>$也就是说f[l][r] = max(f[l][r] || f[l][r-1] || f[l+1][r-1]+2)最后一维代表l和r能够匹配$</li>\n</ul>\n<h2 id=\"树形DP\"><a href=\"#树形DP\" class=\"headerlink\" title=\"树形DP\"></a>树形DP</h2><ul>\n<li>以树上的节点作为dp状态，记 d(u)表示u的整颗子树的的信息，从儿子的状态转移过来</li>\n</ul>\n<h2 id=\"状压DP\"><a href=\"#状压DP\" class=\"headerlink\" title=\"状压DP\"></a>状压DP</h2><h2 id=\"数位DP\"><a href=\"#数位DP\" class=\"headerlink\" title=\"数位DP\"></a>数位DP</h2><p>$\\le n$的满足条件的数字个数</p>\n<p>$\\le 10^n$ 的满足条件的数字个数​</p>\n<p>有不超过$n$个十进制位</p>\n<p>$d_{i,j}$表示从高到低的前i位已经选择完，且最低的位为$j$的方案数</p>\n<p>转移:枚举$i+1$位填的数字$k$，要求，$|j-k|\\ge 2$，从$d(i,j)$转移到$d(i+1,k)$​​​</p>\n<h3 id=\"P2235\"><a href=\"#P2235\" class=\"headerlink\" title=\"P2235\"></a>P2235</h3><p>$f(n) = \\begin{cases} f(1) = 1 \\\\ f(3) = 3 \\\\ f(2n) = f(n) \\\\ f(4n+1) = 2f(2n+1) - f(n)\\\\f(4n + 3) = 3 f(2n+1) - 2f(n) \\end{cases}$</p>\n<ul>\n<li><p>这个函数代表的意思是把n的二进制串翻转</p>\n</li>\n<li><p>所以，很容易想到数位$dp$</p>\n</li>\n<li>设$d(i,c1,c2)$​表示考虑j前i为和后i位，c1</li>\n<li>枚举回文数的第i+1位是k，转移到$d(i+1,c1’,c2’)$</li>\n</ul>\n<h3 id=\"P3281\"><a href=\"#P3281\" class=\"headerlink\" title=\"P3281\"></a>P3281</h3><h3 id=\"The-Last\"><a href=\"#The-Last\" class=\"headerlink\" title=\"The Last\"></a>The Last</h3><ul>\n<li><p>求$\\sum_{i = l}^r\\lgroup ^{a+i} _b  \\rgroup c^i \\mod p$​</p>\n</li>\n<li><p>$p \\le 1e5 , c &lt; p, l, r, a, b \\le 1e18$</p>\n</li>\n<li>$p$为质数</li>\n</ul>\n","text":"DPpart1.动态规划的核心概念 状态 转移方程 初始化 实例揭秘本质—斐波那契数列 $众所周知 斐波那契数列的的递推式是:$ $f_i = f_{i-1} + f_{i-1}(i \\ge 2)$​ $问题来了，如何来求$$f_n$? $这个时候就要用到f_i = f_{i-1...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"DP","slug":"DP","count":2,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":2,"path":"api/tags/动态规划.json"},{"name":"知识点","slug":"知识点","count":14,"path":"api/tags/知识点.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#DP\"><span class=\"toc-text\">DP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#part1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">part1.动态规划的核心概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E6%8F%AD%E7%A7%98%E6%9C%AC%E8%B4%A8%E2%80%94%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\"><span class=\"toc-text\">实例揭秘本质—斐波那契数列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-1-%E7%BB%84%E5%90%88%E6%95%B0\"><span class=\"toc-text\">Problem 1:组合数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-2\"><span class=\"toc-text\">Problem 2:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-3\"><span class=\"toc-text\">$Problem 3$</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-4\"><span class=\"toc-text\">Problem 4</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-5\"><span class=\"toc-text\">Problem 5</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-6\"><span class=\"toc-text\">Problem 6</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Problem-7\"><span class=\"toc-text\">Problem 7</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E9%97%B4DP\"><span class=\"toc-text\">区间DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A0%91%E5%BD%A2DP\"><span class=\"toc-text\">树形DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E5%8E%8BDP\"><span class=\"toc-text\">状压DP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E4%BD%8DDP\"><span class=\"toc-text\">数位DP</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#P2235\"><span class=\"toc-text\">P2235</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#P3281\"><span class=\"toc-text\">P3281</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#The-Last\"><span class=\"toc-text\">The Last</span></a></li></ol></li></ol></li></ol>","author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"优化技巧","uid":"e2573f345f8e369bd93647303f895691","slug":"优化技巧","date":"2021-09-16T09:39:54.000Z","updated":"2021-09-16T12:28:25.303Z","comments":true,"path":"api/articles/优化技巧.json","keywords":null,"cover":null,"text":"DP优化 $f_i = min_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$​​ 使用单调队列优化 $f_i = sum_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$ 使用前缀和优化 $f_i = min_{i ...","link":"","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"DP","slug":"DP","count":2,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":2,"path":"api/tags/动态规划.json"},{"name":"知识点","slug":"知识点","count":14,"path":"api/tags/知识点.json"},{"name":"DP优化","slug":"DP优化","count":1,"path":"api/tags/DP优化.json"}],"author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}