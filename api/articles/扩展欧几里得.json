{"title":"扩展欧几里得","uid":"efce904e2fde083966eb57ba4b88b825","slug":"扩展欧几里得","date":"2021-09-16T12:43:04.000Z","updated":"2021-09-16T12:43:24.083Z","comments":true,"path":"api/articles/扩展欧几里得.json","keywords":null,"cover":null,"content":"<h1 id=\"扩展欧几里得算法\"><a href=\"#扩展欧几里得算法\" class=\"headerlink\" title=\"扩展欧几里得算法\"></a>扩展欧几里得算法</h1><h2 id=\"概况\"><a href=\"#概况\" class=\"headerlink\" title=\"概况\"></a>概况</h2><p>我们之前讲的gcd算法叫做欧几里得算法，下面介绍拓展欧几里得算法(Extended Euclidean algorithm,EXGCD),从它的名字就可以看出来，它是欧几里得算法的拓展。扩欧算法求的是二元一次不定方程$ax + by = gcd(a,b)$的一组整数解</p>\n<p>假设我们已经求出 $bx’ + (a mod b)y’ = gcd(b,a mod b)$的一组解，我们想要求出$ax+by=gcd(a,b)$的解。我们已经知道$gcd(a,b) = gcd(b,a mod b)$。联立两个式子，可得$ax + by =bx’+(a mod b)y’$。</p>\n<p>又因为$a mod b = a - \\lfloor{\\frac{a}{b}\\rfloor} \\times b$所以，</p>\n<p>$ax+by=bx’+ay’ - \\lfloor\\frac{a}{b}\\rfloor \\times b =ay’+b(x’-\\lfloor \\frac{a}{b} \\rfloor \\times y’)$</p>\n<p>于是我们得到了一组解:$x = y’,y = x’ - \\lfloor \\frac{a}{b} \\rfloor \\times y’$</p>\n<p>因此我们可以像求gcd那样往下递归，直到$a=1，b=0，$此时解为$x = 1，y = 0$,然后根据递归的结果求解即可。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><hr>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\"><span class=\"token comment\">//核心代码</span>\n<span class=\"token keyword\">int</span> <span class=\"token function\">exgcd</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> b<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>x<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> <span class=\"token operator\">&amp;</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// x 和 y表示直接引用，表示修改操作可以影响到代入的数</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n        x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> y <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">return</span> a<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token function\">exgcd</span><span class=\"token punctuation\">(</span>b <span class=\"token punctuation\">,</span> a <span class=\"token operator\">%</span> b <span class=\"token punctuation\">,</span> x <span class=\"token punctuation\">,</span> y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> t <span class=\"token operator\">=</span> x<span class=\"token punctuation\">;</span>\n    x <span class=\"token operator\">=</span> y<span class=\"token punctuation\">;</span>\n    y <span class=\"token operator\">=</span> t <span class=\"token operator\">-</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">/</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> y<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> d<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">int</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">scanf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d%d\"</span><span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">,</span><span class=\"token operator\">&amp;</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> d <span class=\"token operator\">=</span> <span class=\"token function\">exgcd</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\">//求得的结果存在x,y里,函数返回的结果为gcd(a,b)</span>\n    <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"%d %d %d\\n\"</span><span class=\"token punctuation\">,</span>d<span class=\"token punctuation\">,</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h1 id=\"The-End\"><a href=\"#The-End\" class=\"headerlink\" title=\"The End\"></a>The End</h1>","text":"扩展欧几里得算法概况我们之前讲的gcd算法叫做欧几里得算法，下面介绍拓展欧几里得算法(Extended Euclidean algorithm,EXGCD),从它的名字就可以看出来，它是欧几里得算法的拓展。扩欧算法求的是二元一次不定方程$ax + by = gcd(a,b)$的一...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"数学","slug":"数学","count":4,"path":"api/tags/数学.json"},{"name":"拓展欧几里得","slug":"拓展欧几里得","count":1,"path":"api/tags/拓展欧几里得.json"},{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">扩展欧几里得算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E5%86%B5\"><span class=\"toc-text\">概况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#The-End\"><span class=\"toc-text\">The End</span></a></li></ol>","author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"最短路径问题","uid":"665dc3c56673e4afdc879c20d4cbcde8","slug":"最短路径问题","date":"2021-09-16T12:44:06.000Z","updated":"2021-09-16T12:46:12.290Z","comments":true,"path":"api/articles/最短路径问题.json","keywords":null,"cover":null,"text":"最短路径问题最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 松弛操作在讲松弛操作之前，我们要先明确一个事实 那就是在计算两点间的最短路时，通常不仅仅会算出两点间的最短路，而会把许多点之间的最短路一同算出来 那…… 这是为什么呐...","link":"","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"图论","slug":"图论","count":7,"path":"api/tags/图论.json"},{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"最短路","slug":"最短路","count":1,"path":"api/tags/最短路.json"},{"name":"Dijkstra","slug":"Dijkstra","count":1,"path":"api/tags/Dijkstra.json"},{"name":"SPFA","slug":"SPFA","count":1,"path":"api/tags/SPFA.json"},{"name":"Bellman-Ford","slug":"Bellman-Ford","count":1,"path":"api/tags/Bellman-Ford.json"},{"name":"三角不等式","slug":"三角不等式","count":1,"path":"api/tags/三角不等式.json"}],"author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"基础数据结构","uid":"7ff326fdf142ec1868a8e7b87c57157c","slug":"基础数据结构","date":"2021-09-16T12:40:16.000Z","updated":"2021-09-16T12:41:19.043Z","comments":true,"path":"api/articles/基础数据结构.json","keywords":null,"cover":null,"text":"基础数据结构链表:因为数组的插入和删除很慢，所以我们引入了链表这个概念,那么链表是什么样的一个数据结构呢? 定义:每一个元素都有箭头指向下一个元素,同理每一个元素都有箭头指向上一个元素,即 依靠箭头把n个数连接起来的一个数据结构 代码实现(包括插入和删除) cpp //核心代码 ...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[],"tags":[{"name":"知识点","slug":"知识点","count":14,"path":"api/tags/知识点.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"},{"name":"链表","slug":"链表","count":1,"path":"api/tags/链表.json"},{"name":"栈","slug":"栈","count":1,"path":"api/tags/栈.json"},{"name":"队列","slug":"队列","count":1,"path":"api/tags/队列.json"},{"name":"STL","slug":"STL","count":1,"path":"api/tags/STL.json"},{"name":"树","slug":"树","count":1,"path":"api/tags/树.json"},{"name":"二叉树","slug":"二叉树","count":1,"path":"api/tags/二叉树.json"},{"name":"堆","slug":"堆","count":1,"path":"api/tags/堆.json"}],"author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}