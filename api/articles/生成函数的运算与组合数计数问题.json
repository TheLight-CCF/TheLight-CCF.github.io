{"title":"生成函数的运算与组合数计数问题","uid":"942862e9c14bb68bd04eca0737914553","slug":"生成函数的运算与组合数计数问题","date":"2021-09-16T09:32:38.000Z","updated":"2021-09-17T00:21:21.149Z","comments":true,"path":"api/articles/生成函数的运算与组合数计数问题.json","keywords":null,"cover":[],"content":"<h1 id=\"生成函数的运算与组合数计数问题\"><a href=\"#生成函数的运算与组合数计数问题\" class=\"headerlink\" title=\"生成函数的运算与组合数计数问题\"></a><center>生成函数的运算与组合数计数问题</center></h1><p><strong>摘要</strong></p>\n<p>​    本文介绍了处理形式幂级数的一些高效算法，并在生成函数的运算过程中加以应用，从而解决一系列组合计数问题。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p><strong>$1$.引言</strong></p>\n<p><strong>$2$.多项式与形式幂级数</strong></p>\n<p>​    $2.1$ 多项式</p>\n<p>​    $2.2$ 多项式的基本运算</p>\n<p>​    $2.3$ 形式幂级数</p>\n<p><strong>$3$.组合计数问题</strong></p>\n<p>​    $3.1$ 组合对象</p>\n<p>​    $3.2$ 普通生成函数</p>\n<p>​    $3.3$ 指数生成函数</p>\n<p><strong>$4$.乘法逆元</strong></p>\n<p><strong>$5$.乘法逆元的应用</strong></p>\n<p><strong>$6$. 对数与指数运算</strong></p>\n<p>​    $6.1$ 复合运算</p>\n<p>​    $6.2$ 形式导数</p>\n<p>​    $6.3$​ 对数函数与指数函数</p>\n<hr>\n<p>​            $6.3.1$ 对数函数的计算</p>\n<p>​            $6.3.2$ 指数函数的计算</p>\n<p>​    $6.4$ 牛顿迭代法</p>\n<p>​    $6.5$ $k$次幂的计算</p>\n<p>$7$ 集合的计数</p>\n<p>​    $7.1$ 有标号集合的计数</p>\n<p>​    $7.2$ 无标号集合的计数</p>\n<p>$8$ 环的计数</p>\n<p>​    $8.1$ 有标号环的计数</p>\n<p>​    $8.2$ 无标号环的计数</p>\n<p>$9$ 复合运算</p>\n<p>​    $9.1$ 复合与复合逆</p>\n<p>​    $9.2$ $Lagrange$反演</p>\n<p>$10$ 二元生成函数</p>\n<p>$11$ 结语</p>\n<hr>\n<h2 id=\"1-​-引言\"><a href=\"#1-​-引言\" class=\"headerlink\" title=\"$1$​ 引言\"></a>$1$​ 引言</h2><p>​    组合计数问题是信息学竞赛中常见的一类问题，而生成函数往往是解决这类问题的重要工具。近年来，信息学竞赛中出现了这样一类计数问题，不仅需要选手根据题意对生成函数进行分析与推导，还要求使用高效的算法完成各类多项式运算，才能优化求解的时间复杂度。本文将对这一类问题进行进一步分析与总结。</p>\n<p>​    本文第2，3节回顾了一些需要用到的基本知识。其中第2节提到了几种熟知的多项式乘法算法，以及算法实现时需要注意的地方；第3节引入了组合对象的生成函数的概念，并分析了生成函数加法、乘法的组合意义。</p>\n<p>​    第4节介绍了求解形式幂级数乘法逆元的牛顿迭代法，这一算法是后文许多算法的基础。第5节中的例题对该算法进行了简单应用。</p>\n<p>​    第6节介绍了形式幂级数的对数，指数函数的求解算法。</p>\n<p>​    第7，8节分析了集合、环这两类常见组合模型的计数方法，并对第6节中的算法进行了简单应用。</p>\n<p>​    第9节简单介绍与复合运算相关的算法和定理。</p>\n<p>​    第10节介绍了运用二元生成函数解决问题的技巧。</p>\n<h2 id=\"2-多项式与形式幂级数\"><a href=\"#2-多项式与形式幂级数\" class=\"headerlink\" title=\"$2$ 多项式与形式幂级数\"></a>$2$ 多项式与形式幂级数</h2><h3 id=\"2-1-多项式\"><a href=\"#2-1-多项式\" class=\"headerlink\" title=\"$2.1$ 多项式\"></a>$2.1$ 多项式</h3><p>​        多项式是我们熟知的数学概念。一个关于x的多项式可以写成 </p>\n<script type=\"math/tex; mode=display\">\nA(x) = \\sum_{i = 0}^{n-1} a_ix^i</script><p>的形式，其中系数$a_i$均为某个环$R$中$^①$​的元素。这些多项式组成多项式环$R[x]$。</p>\n<p>​        非零多项式$A(x)$的次数定义为其最高次项的系数，记为$deg A(x)$。</p>\n<h3 id=\"2-2-多项式的基本运算\"><a href=\"#2-2-多项式的基本运算\" class=\"headerlink\" title=\"$2.2$ 多项式的基本运算\"></a>$2.2$ 多项式的基本运算</h3><p>​        设参与运算的多项式中最高次数为$n$。那么多项式的加法、减法显然可以在$O(n)$时间内计算。</p>\n<hr>\n<p>①一般指可交换环，可以是复数域$C$、实数域$R$、整数环$Z$、剩余类环$Z/nZ$等。</p>\n<hr>\n<p>​        我们关心的是两个多项式的乘积。朴素的计算方法需要$O(n^2)$时间，并不够优秀。</p>\n<p>​        一中优化方法是分治乘法$^②$，它的原理是利用</p>\n<script type=\"math/tex; mode=display\">\n(Ax^m + B)(Cx^m + D) \\\\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =ACx^{2m} + ((A + B)(C + D) - AC - BD)x^m + BD</script><p>减少乘法次数进行递归。复杂度为$O(n^{\\log_23}) = O(n^{1.585})$。</p>\n<p>​        分治乘法的劣势在于复杂度较高，但它不涉及除法，所以对环$R$没有特别的要求。</p>\n<p>​        此外，当运算在模2意义下进行时，我们也可以利用位运算加速，使得算法常数减小到原来的$1/32$。</p>\n<p>​        另一种做法是$FFT^③$​。它利用单位根的性质，实现了多项式的系数与点值表示之间的快速转化。时间复杂度是$O(n logn)$。</p>\n<p>​        为了使用$FFT$，$R$需具有$2^k$次单位根($2^k \\ge 2n$)，且存在2的乘法逆元。当系数在复数域内时，单位根总能找到，但计算时容易出现精度问题。</p>\n<p>​        需要注意到的是，信息学竞赛中涉及的计数问题往往要求答案模一个大质数$p$(如$1e9+7$或$998244353 = 7 \\times 17 \\times 2^{23} +1$等等)后输出。这样的好处包括：每次算术运算的时间可以视作$O(1)$，不存在精度问题，且大多数情况可以支持除法(只要在问题规模范围内，除数都远小于$p$，存在乘法逆元)。因此本文中假设所有运算都在$F_p$下进行。</p>\n<p>​        在模$p$​意义下进行$FFT$​时，若满足$2^k|\\varphi(p) = p -1$​，则可取$p$​的原根$g$​，并用$g^{\\frac{p-1}{2^k}}$​作为单位根；否则，将系数视作$Z$​的元素进行运算后再对$p$​取模。这时，相乘得到的系数大小不超过$np^2$​​，只要取若干个便于$FFT$​的大质数分别进行运算，再用中国剩余定理（$CRT$）还原系数即可。</p>\n<h3 id=\"2-3-形式幂级数\"><a href=\"#2-3-形式幂级数\" class=\"headerlink\" title=\"$2.3$ 形式幂级数\"></a>$2.3$ 形式幂级数</h3><p>​        一个多项式仅有有限项的系数是非零的。若去掉这一限制，可将其推广为形式幂级数</p>\n<script type=\"math/tex; mode=display\">\nA(x) = \\sum_{i \\ge 0} a_ix_i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2,2)</script><p>————————————————————</p>\n<p>②详见<a href=\"http://en.wikipedia.org/wiki/Karatsuba_algorithm\">http://en.wikipedia.org/wiki/Karatsuba_algorithm</a></p>\n<p>③详见<a href=\"http://en.wikipedia.org/wiki/Discrete_Fourier_transform\">http://en.wikipedia.org/wiki/Discrete_Fourier_transform</a></p>\n<hr>\n<p>它们组成了形式幂级数中环$R[[x]]$。</p>\n<p>​        此定义中，$x$仅作为一个符号，而不用具体的数值带入运算，故不必考虑与幂级数敛散性有关的问题。</p>\n<p>​        我们用$[x^n]A(x)$表示$A(x)$的$n$次项系数$a_n$。</p>\n<p>​        形式幂级数的加减法与乘法也可与多项式运算类似定义：</p>\n<script type=\"math/tex; mode=display\">\nA(x) = \\sum_{i \\ge 0} a_ix^i，B(x) = \\sum_{i \\ge 0} b_ix^i，\\ \\ \\ \\ \\ \\ \\ (2.3) \\\\\nA(x) \\pm B(x) = \\sum_{i \\ge 0} (a_i \\pm b_i)x^i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\  \\ \\ (2.4) \\\\\nA(x)B(x) = \\sum_{k \\ge 0} (\\sum_{i+j = k}a_ib_j)x^k \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2.5)</script><p>​        实际运算时，通常只需保留次数不超过$n - 1$的项进行计算，并将多余的项舍去(即在模$x^n$意义下计算)。因此加减法的复杂度为$O(n)$，乘法的复杂度为$O(nlogn)$。</p>\n<h2 id=\"3-组合计数问题\"><a href=\"#3-组合计数问题\" class=\"headerlink\" title=\"$3$组合计数问题\"></a>$3$组合计数问题</h2><h3 id=\"3-1-组合对象\"><a href=\"#3-1-组合对象\" class=\"headerlink\" title=\"$3.1$ 组合对象\"></a>$3.1$ 组合对象</h3><p>​        组合计数问题是一类常见的问题。这类问题中一般定义了一类组合对象$A$​，它可能是满足某一性质的树、图、串等对象的集合；其中每个对象$a \\in A$​都被定义了大小$size(a)\\in n$​的对象$a$的数量是有限的，计作$A_n$。我们的任务通常为求出$A_n$的数值。</p>\n<p>​        根据不同的问题要求，组合对象可以分为有标号和无标号两类。下面简单以无向图为样例解释它们的区别：</p>\n<p>​        n个点的标号图中，每个顶点都被赋予了$1,2,\\cdots，n$中的唯一标号；然而在无标号图中，每个顶点的地位是没有区别的。如图所示，$n = 3$时，无标号的简单无向图共有四种，而有标号的简单无向图有$8$种。</p>\n<p><img src=\"https://finallight.oss-cn-shanghai.aliyuncs.com/%E8%AE%BA%E6%96%87/lunwen.png\" alt=\"\"></p>\n<hr>\n<p><img src=\"https://finallight.oss-cn-shanghai.aliyuncs.com/%E8%AE%BA%E6%96%87/lunwen2.png\" alt=\"\"></p>\n<h3 id=\"3-2-普通生成函数\"><a href=\"#3-2-普通生成函数\" class=\"headerlink\" title=\"$3.2$ 普通生成函数\"></a>$3.2$ 普通生成函数</h3><p>​        数列$A_0,A_1,\\cdots$的普通生成函数（$Ordinary Generating Function，OGF$）定义为形式幂级数</p>\n<script type=\"math/tex; mode=display\">\nA(x) = \\sum_{i \\ge 0} A_ix^i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.1)</script><p>​        $A$是一类无标号对象，则$A$的普通生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的普通生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。</p>\n<p>​        对于两类无标号对象$A,B$，定义一类新的对象$C = A \\cup B$，若$A，B$交集为空，则$C$的生成函数即为</p>\n<script type=\"math/tex; mode=display\">\nC(x) = A(x) + B(x).        \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.2)</script><p>​        再来考虑$A,B$的笛卡尔积$D = A \\times B$，其中$D$的每个元素$d$都是一个二元组$(a,b)$，其中$a \\in A,b \\in B$，并定义$size(d) = size(a) + size(b)$。则有</p>\n<script type=\"math/tex; mode=display\">\nD_k = \\sum_{i + j = k}A_iB_j，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3,3)</script><p>于是$D$的$OGF$即为</p>\n<script type=\"math/tex; mode=display\">\nD(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.4)</script><p>这一操作实现了$A$中元素和$B$中元素的拼接。</p>\n<h3 id=\"3-3-指数生成函数\"><a href=\"#3-3-指数生成函数\" class=\"headerlink\" title=\"$3.3$ 指数生成函数\"></a>$3.3$ 指数生成函数</h3><p>​        数列$A_0，A_1,\\cdots$的指数生成函数（ $Exponential Generating Function，EGF$​）定义为形式幂级数</p>\n<script type=\"math/tex; mode=display\">\nA(x) = \\sum_{i \\ge 0} A_i\\frac{x_i}    {i!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.5)</script><hr>\n<p>指数生成函数在处理有标号问题时更加便捷。对于一类有符号对象$A$，$A$的指数生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的指数生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。</p>\n<p>​        给定两类有标号对象$A,B$，对于它们的并集$C = A \\cup B$，同样有</p>\n<script type=\"math/tex; mode=display\">\nC(x) = A(x) + B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.6)</script><p>​        现在考虑有标号对象的拼接。给定两个对象$a,b$​，设$size(a) = n$​ ，$size(b) = m$​，他们分别带有$1,2,\\cdots,n$​和$1,2,\\cdots,m$​的标号。为将$a,b$​拼接得到$c$​，需给$c$​分配$1,2,\\cdots,n+m$​的标号。规定重新分配时需要保持标号的原有相对顺序，则有</p>\n<script type=\"math/tex; mode=display\">\n\\binom{n+m}{n} = \\frac{(n+m)!}{n!m!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.7)</script><p>种方法</p>\n<p>​        因此。若将两类带标号对象$A,B$拼接得到$D$，则有</p>\n<script type=\"math/tex; mode=display\">\nD_k = \\sum_{i + j = k} A_iB_j \\frac{k!}{i!j!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.8)</script><p>从而$D$的$EGF$也具有</p>\n<script type=\"math/tex; mode=display\">\nD(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.9)</script><p>的形式。</p>\n<h2 id=\"4-乘法逆元\"><a href=\"#4-乘法逆元\" class=\"headerlink\" title=\"$4$ 乘法逆元\"></a>$4$ 乘法逆元</h2><p>​        当$A(x)B(x) = 1$时，称$A(x)，B(x)$互为乘法逆元，可以写作$A(x) = B(x)^{-1}   = 1 / B(x)$。除以一个形式幂级数，就相当于乘上它的乘法逆元。</p>\n<p>​        例如，</p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{1 - x} = 1 + x + x^2 + x^3 + \\cdots.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.1)</script><p>根据这一等式可得，若数列$a_0,a_1,\\cdots$的普通生成函数为$A(x)$，令$s_n = \\sum_{i = 0}^{n}a_i$，那么$s_0,s_1,\\cdots$的普通生成函数为$A(x)/(1-x)$。</p>\n<p>​        再结合二项式系数的递推性质，可得</p>\n<script type=\"math/tex; mode=display\">\n\\frac{1}{(1-x)^{n+1}} = \\sum_{i \\ge 0} \\binom{n+i}{n}x^i \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.2)</script><hr>\n<p>​        接下来介绍，在给定$A(x)$时，如何求出$A(x)$的乘法逆元$B(x)$。</p>\n<p>​        可以证明，$A(x)$存在乘法逆元的充要条件是$A(x)$的常数项存在乘法逆元。必要性由$([x^0]A(x))([x^0]B(x)) = 1$​可得。而当$A(x)$的常数项可逆时，即可根据乘法的定义($2.5$)按顺序求出$[x^1]B(x),[x^2]B(x),\\cdots$的值，于是此时乘法逆元存在且唯一。同时，我们得到了一个求出乘法逆元前$n$项的$O(n^2)$朴素算法。</p>\n<p>​        下面介绍一个用$O(nlogn)$时间计算乘法逆元的算法，它的本质是牛顿迭代法。</p>\n<p>​        首先求出$A(x)$的常数项的逆元$b$，并令$B(x)$的初始值为$b$。</p>\n<p>​        假设已求满足</p>\n<script type=\"math/tex; mode=display\">\nA(x)B(x) \\equiv 1\\pmod  {x^n} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.3)</script><p>的$B(x)$，则</p>\n<script type=\"math/tex; mode=display\">\nA(x)B(x) - 0 \\equiv 0 \\pmod {x^n}， \\\\\n(A(x)B(x) - 1)^2 \\equiv 0 \\pmod {x^{2n}}， \\\\\nA(x)(2B(x) - B(x)^2 A(x)) \\equiv 1 \\pmod {x^{2n}}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.4)</script><p>我们用$o(n logn)$时间计算出$2B(x) - B(x)^2A(x)$，并将它赋值给$B(x)$进行下一轮迭代。每迭代一次，$B(x)$的有效项数$n$都会增加一倍。于是该算法的时间复杂度为</p>\n<script type=\"math/tex; mode=display\">\nT(n) = T(n/2) + O(n logn) = O(nlogn).</script><h2 id=\"5-乘法逆元的应用\"><a href=\"#5-乘法逆元的应用\" class=\"headerlink\" title=\"$5$  乘法逆元的应用\"></a>$5$  乘法逆元的应用</h2><p><strong>例题1</strong>(序列计数).<em>你有若干种不同颜色的骨牌，其中大小为$1 \\times i$的骨牌共有$a_i$种。每种骨牌都可以无限量使用。用骨牌不重叠地铺满一排$1 \\times n$的方格，共有几种方法？($a_i,n \\le 10^5$​)</em></p>\n<p>​        我们枚举使用的骨牌数量$k$。设$A(x) = \\sum_{i \\ge 0}a_ix_i$，则根据生成函数的乘法的意义，容易知道此时的答案为$[x^n]A(x)^k$。所以总方法数目为</p>\n<script type=\"math/tex; mode=display\">\n[x^n]\\sum_{k \\ge 0} A(x) = [x^n]\\frac{1}{1 - A(x)}. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.1)</script><p>于是只需计算$1 - A(x)$的乘法逆元即可，时间复杂度$O(n logn)$。    </p>\n<hr>\n<p>​        一般地，对于这一类组合对象$A$，由$A$的元素组成的序列定义一类新的组合对象$B$，则$B$的生成函数为</p>\n<script type=\"math/tex; mode=display\">\nB(x) = \\frac{1}{1 - A(x)}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.2)</script><p>这一结论对于无标号$(OGF)$、有标号$(EGF)$的情况都成立。</p>\n<p><strong>例题2</strong>(预处理$Bernoulli$).</p>\n<p>对于所有$0 \\le i \\le n-1$求出$B_i$。($n \\le 10^5$)</p>\n<p>$Bernoulli数B_0,B_1,\\cdots的指数生成函数为$</p>\n<p>$B(x) = \\sum_{i \\ge 0} B_i\\frac{x^i}{i!} \\\\<br>=\\frac{x}{e^x -1}             (5.3) \\\\<br>=(\\sum_{i \\ge 0}\\frac{x^i}{(i+1)!})^{-1}.<br>$<br>这样，只要求一次乘法逆元即可。</p>\n<p><strong>例题3.</strong>$字符集大小为m。给定一个长度为k的字符串s，求出所有长为n的串中，不包含子串s\\\\的共有几个$</p>\n<p>$  假定串的下标都从1开始$</p>\n<p>$  考虑DP，用f_i表示有多少种方法填前i个字符，使得第一次匹配上串s的位置是$ $[i-k+1,i]。当i &lt; k时,f_i = 0;当i \\ge k$，</p>\n<script type=\"math/tex; mode=display\">f_i = m^{i-k} - \\sum_{0 \\le j \\le i - k}f_im^{i-k-j} - \\sum_{d > 0,d \\in C} f_{i-d}，</script><p>$其中集合C定义为{d \\ge 0 | s[d+1,k] = s[1,k-d]}。$</p>\n<p>$这个DP方程的含义是，末尾k的字符与串s相同，前i-k位字符可以任意确定，但为了保证i - k + 1是第一次匹配上的位置，需要从中减去之前已经匹配过的情况。减去的第一项是这次匹配与上一次没有重叠的情况，第二项是与上次出现重叠的情况，为此需要先用KMP算法求出C的集合。$</p>\n<p>$为了优化这个DP，考虑f的生成函数f(x) = \\sum_{i \\ge 0} f_i x^i。令C(x) = \\sum_{d \\in C^{x^d}}，则可由DP方程写出$</p>\n<p>$f(x) = \\frac{x^k}{1 - mx} - \\frac{x^k f(x)}{1 - mx} - f(x)(c(x) - 1)，$</p>\n<hr>\n<p>$定义见$<a href=\"http://en.wikipedia.org/wiki/Bernoulli%5fnumber\">http://en.wikipedia.org/wiki/Bernoulli%5fnumber</a></p>\n<hr>\n","text":"生成函数的运算与组合数计数问题摘要 ​ 本文介绍了处理形式幂级数的一些高效算法，并在生成函数的运算过程中加以应用，从而解决一系列组合计数问题。 目录$1$.引言 $2$.多项式与形式幂级数 ​ $2.1$ 多项式 ​ $2.2$ 多项式的基本运算 ​ $2.3$ 形式幂级数 $3...","link":"","photos":[],"count_time":{"symbolsCount":"7.8k","symbolsTime":"7 mins."},"categories":[],"tags":[{"name":"知识点","slug":"知识点","count":14,"path":"api/tags/知识点.json"},{"name":"数学","slug":"数学","count":4,"path":"api/tags/数学.json"},{"name":"生成函数","slug":"生成函数","count":1,"path":"api/tags/生成函数.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E7%AE%97%E4%B8%8E%E7%BB%84%E5%90%88%E6%95%B0%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">生成函数的运算与组合数计数问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">目录</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E2%80%8B-%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">$1$​ 引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E4%B8%8E%E5%BD%A2%E5%BC%8F%E5%B9%82%E7%BA%A7%E6%95%B0\"><span class=\"toc-text\">$2$ 多项式与形式幂级数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%A4%9A%E9%A1%B9%E5%BC%8F\"><span class=\"toc-text\">$2.1$ 多项式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">$2.2$ 多项式的基本运算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%BD%A2%E5%BC%8F%E5%B9%82%E7%BA%A7%E6%95%B0\"><span class=\"toc-text\">$2.3$ 形式幂级数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%BB%84%E5%90%88%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">$3$组合计数问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E7%BB%84%E5%90%88%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">$3.1$ 组合对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%99%AE%E9%80%9A%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">$3.2$ 普通生成函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E6%8C%87%E6%95%B0%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">$3.3$ 指数生成函数</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83\"><span class=\"toc-text\">$4$ 乘法逆元</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83%E7%9A%84%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">$5$  乘法逆元的应用</span></a></li></ol></li></ol>","author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"https://github.com/TheLight-CCF","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/thelight-59","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/78969213"}}}},"mapped":true,"prev_post":{"title":"DP","uid":"25ed3aa3446c2c64cf6228f9f4e4f9c4","slug":"DP","date":"2021-09-16T09:38:51.000Z","updated":"2021-09-16T12:28:18.110Z","comments":true,"path":"api/articles/DP.json","keywords":null,"cover":null,"text":"DPpart1.动态规划的核心概念 状态 转移方程 初始化 实例揭秘本质—斐波那契数列 $众所周知 斐波那契数列的的递推式是:$ $f_i = f_{i-1} + f_{i-1}(i \\ge 2)$​ $问题来了，如何来求$$f_n$? $这个时候就要用到f_i = f_{i-1...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"DP","slug":"DP","count":2,"path":"api/tags/DP.json"},{"name":"动态规划","slug":"动态规划","count":2,"path":"api/tags/动态规划.json"},{"name":"知识点","slug":"知识点","count":14,"path":"api/tags/知识点.json"}],"author":{"name":"TheLight","slug":"blog-author","avatar":"https://finallight.oss-cn-shanghai.aliyuncs.com/images/TheLight.jpg","link":"/","description":"There is TheLight's blog,Thanks for your exploring.","socials":{"github":"https://github.com/TheLight-CCF","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/thelight-59","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/78969213"}}}}},"next_post":{}}