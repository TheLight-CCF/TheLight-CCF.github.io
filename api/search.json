[{"id":"0366be0c07e758eb327e5de2aedcedbb","title":"topsort and 2-SAT","content":"拓扑排序\n给定一个有向图，求出一个点的序列，使得对于每条边$u \\to v$都满足$u$在$v$的前面出现。\n$1 \\to 2,1 \\to 3,2 \\to 4,3 \\to 4$,则$1,2,3,4$和$1,3,2,4$都合法。\n$1\\to 2$,$2 \\to 1$ 则无解\n\n\n有环的图一定没有拓扑排序\n结论：对有向无环图($DAG$)，一定有拓扑序\n\n$Code:$\n伪代码:\naddedge(u,v):deg[v]++\n\nqueue&lt;int> Q;\n\nfor i in graph:\n\t\t\tif deg[i] = 0;\n\t\t\t\t\t\tQ.push(i)\nwhile Q not empty:\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\ta[++cnt] = u;\nfor(u -> v) in graph:\n\t\t\t--deg[v];\n\t\t\tif deg[v] == 0;\n\t\t\tQ.push(v);\n\n\n每次选一个入度为$0$的点，加到拓扑排序末尾，然后在原图里删掉这个点和它的所有初边。\n\n\n算法结束时，如果还有点没被删除，说明图中有环\n $DAG$为什么一定有拓扑序\n数学归纳法：假设点数为$n-1$的图成立，推到点数为$n$时成立。\n\n\n$Directing\\  Edges(CF1385E)$​\n\n给定一个$n$个点混合图，有$m$条有向边和$k$条无向边。给无向边定向，使它成为$DAG$，或判断无解。\n$m,m,k \\le$\n把只包含有向边的图拓扑排序\n无向边按照拓扑排序定向\n\n\n$DAG$最长链\n\n给定一个$DAG$,每个点有权值(可以是负数),问选一条链，权值和最大是多少。\n不懂\n\n\n传递闭包\n\n给定一个$n$个点m条边的DAG，对每个点求出它能到达多少点\n$n,m \\le 10^5$\n题解：记$S_u$为$u$能到达的点集。\n按拓扑排序倒序转移:$S_u = {u} + U_{i \\to v}S_v$\n看成二进制数,用$bitset$优化\n时间$O（\\frac{nm}{w}）$，在64位机上$w = 64$​\n\n\n$Reboot\\  from\\  Blue(lg 7480)$\n\n数轴上有n个加油站,第i个为于$x_i$,油价为每升c_i元\n起点坐标s，终点t，车油箱一开始是空的，且保证起点处有加油站，假设箱子容量无限大，一升油可以走距离1\n求出最小花费\n$1 \\le n \\le 10^5$,$-10^9 \\le x_i,s,t \\le 10^9,s &lt; t$\n**题解:**可能会往回走\n最优策略：每次刚好跑到一个油钱更小的加油站\n单调栈求左右两边第一个油钱更小的加油站，连边\n连出一个$DAG$，跑s到所有点到最段路，用它更新答案\n不用跑最短路，直接跑$dp$​\n\n\n最小拓扑序\n\n求$DAG$拓扑序中字典序最小的\n**题解:**用小根堆存入度为0的点，每次取出最小的\n\n\n树的拓扑排序个数\n\n给定一颗外向树,问拓扑排序个数\n$n \\le 10^6$\n**题解:**给每个点$i$一个标号$p_i$,表示它在拓扑序中出现的位置。\n对每条边$u \\to v$,都要满足$p_u \\le p_v$\n$dfs(x,S):$决定x子树内的标号，每个点的标号都在集合S中取。\n先给$x$标上$S$中的最小元素,并在S中删除这个元素。\n再将$S$分配给每个儿子的子树，递归调用$dfs(y,S’)$​。\n方案数:$\\prod_{x} \\frac{(size[x] - 1)!}{\\prod_{y \\in sons(x)}(size[y])!}$\n化简:$\\frac{n!}{\\prod_{x}size[x]}$​\n概率角度：点x的标号为集合中最小的数的概率为$\\frac{1}{size[x]}$​。\n\n\n拓扑序计数\n\n给定$n$个点$m$条边的有向图，每条边可能出现/不出现，对所有$2^m$种情况，求图中拓扑排序个数的和。\n$n \\le 20$\n不懂\n\n\n新题目\n\n有$n$个变量$x_1,\\cdots,x_n$，全都是正整数，给定$m$条$x_i &lt; x_j$的关系，求所有合法解中，$x$最大值的最小值\n\n\n牛x的点\n\n给定一个n个点m条边的DAG面对每个点x，判断它是否满足：对于图中任意一点y要么从x能到y，要么从y能到x。\n$n,m \\le 10^6$\n不懂\n\n\n庆典 ($NOI\\  2021\\  D1T3$​​)\n\n不懂\n\n\n$Insider’s \\  Infromation$​\n\n有一个排列满足m条形如$\\lceil y$出现在$x,z$之间的限制$\\rfloor$ ，现在你需要构造一个排列满足至少$\\lceil \\frac{m}{2} \\rceil$个限制\n\n\n$DAG$重链剖分\n\n给一个字符串S，令T是S的所有非空子序列的集合（相同的子序列会被去重）\n比如apia的子序列为{a,aa,ai,aia,ap,apa,api,apia,i,ia,p,pa,pi,pia}\n有Q个询问，回答字典序从小到大第k的子序列后p个字符，不如第10个子序列为ia\n\n\n\n\n2-SAT\n一些问题看着像2-SAT，实际上不能做\n\n最大一个数\n1个数能否超过一半\n等等\n\n\n给定n个点m条边的无向图，每个点选一个邻边，不能重复选，构造一组解\n\n可以2-SAT，但没必要\n\n\n$Radio\\  Stations$​​\n\n有 $n$ 个电台，频段在 $[l(i), r(i)]$ 之间。\n\n由你在 $[1, m]$ 中选频段 $f$。区间不包含 $f$ 的电台不能被启用。\n\n给$k$条限制，有两种：\n\n\n$1$.电台$u$和$v$至少选一个\n$2$.电台$u$和$v$不能同时选\n\n\n输出$f$和选择方案。\n\n$n, m, k &lt;= 4×10^5$​\n\n\n\n编码(loj 6036)\n\n有 $n$ 个二进制串，每个串有一位是 ?\n你要给 $?$ 填上 $0/1$，使得不存在 $i, j$ 使 $s[i]$ 是 $s[j]$ 的前缀\n\n\n\nPracticeKnights of the Round Table (POJ 2942)有 $n$ 个骑士，有 $m$ 对骑士相互憎恨。骑士可能召开圆桌会议，骑士们围绕着圆桌而坐，需要满足\n\n骑士的个数是大于 $1$ 的奇数。\n任何相邻的一对骑士都不相互憎恨。\n\n求有多少骑士不可能参加任何圆桌会议。\n$1\\le n\\le 1,000$$1\\le m\\le {n\\choose 2}$\nRoad Construction (POJ 3352)有一个岛上有 $n$ 个旅游景点，有 $m$ 条双向道路连接着它们。现在要修建一些额外的道路，使得任意一条道路封闭后游客都能从一个旅游景点到达任意的旅游景点。求最少需要修建的道路数量。\n$3\\le n\\le 1,000$$2\\le m\\le 1,000$\nMining Your Own Business (UVA 1108)有一张无向图，选一些点涂黑，满足任意删除一个点后（可能是被涂黑的点），每个连通分量都有至少一个黑点。求最少涂黑的点数和方案数。\n$1\\le n\\le 50,000$\nEquivalent Sets (HDU 3836)给定一张有向图，求至少添加多少条边能使得其强连通。\n$1\\le n\\le 20,000$$0\\le m\\le 50,000$\nPursuit For Artifacts (CF652E)给定一张简单无向连通图，边权为 $0$ 或 $1$，求从 $a$ 到 $b$ 是否存在一条边权和非 $0$ 的且不经过重复边的路径。\n$1\\le n\\le 300,000$$0\\le m\\le 300,000$\nMuseums Tour (CF1137C)一个国家有 $n$ 个城市，和 $m$ 条单向道路，每周有 $d$ 天。每个城市都有一个博物馆，每天博物馆的开放情况只和是一周中的哪一天有关，即每 $d$ 天一个循环。\n从一周中的第一天，城市 $1$ 开始，每天参观博物馆（如果开放），之后沿着一条边走到下一个城市。求无限的时间内最多能参观多少不同的博物馆。\n$1\\le n\\le 100,000$$0\\le m\\le 100,000$$0\\le d\\le 50$\nLeaders (CF97E)给定一张简单无向图，多次询问两个点之间是否存在长度为奇数的简单路径。\n$1\\le n\\le 100,000$$0\\le m\\le 100,000$$1\\le q\\le 100,000$\nSimple Cycles Edges (CF962F)给定一张简单无向图，求哪些边在恰好一个简单环内。\n$1\\le n\\le 100,000$$0\\le m\\le 100,000$\nCaterpillar (CF51F)定义毛毛虫是一张无环图，满足存在一条路径使得每个点离这条路径的距离不超过 $1$。给定一张无向图，现在可以每次合并两个顶点使得图变成毛毛虫。求最少需要的操作数。\n$1\\le n\\le 2000$$0\\le m\\le 10^5$\n","slug":"topsort-and-2-SAT","date":"2021-09-16T09:42:01.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"43339b4e6d7b5864c06090c0390d8a24","title":"图的强连通性质，桥，割点以及相关应用","content":"目录\n强连通\n\n强连通的定义\n强连通分量\nTarjan 强连通分量算法\n强连通性的应用\n\n\n边双连通\n\n边双连通分量的定义\n边双连通分量\nTarjan 边双连通分量算法\n边双连通性的应用\n\n\n点双连通\n\n点双连通的定义\n点双连通分量\nTarjan点双连通分量算法和圆方树\n\n\n\n\n强连通\n强连通的定义\n\n给定有向图$G = (V,E)。$\n对于$u,v \\in V$​，若$G$​中同时存在$u$​到$v$​的路径和$v$​到$u$​的路径，则称$u$​和$v$​​​强连通($strongly\\  connected$)\n对于任意的$u,v \\in V$都有$u$和$v$​强连通,则称有向图$G$强连通。\n\n\n强连通分量\n\n注意到顶点的强连通是一个等价关系。\n自反性:对任意的 $u \\in V$​，$u$和$u$强连通。\n对称性:对任意的$u,v \\in V$,若$u$和$v$强连通，则$v$和$u$​强连通。\n传递性:对于任意的$u,v,w \\in V$,若$u$和$v$强连通且$v$和$w$强连通，则$u \\to v \\to w$，$w \\to v \\to u$，因此$u$和$w$强连通\n(注意到顶点的强连通是一个等价关系)根据这个等价关系，我们可以将有向图 $G$​ 的顶点划分为若干个等价类，满足两顶点强连通 当且仅当它们在同一个等价类中。\n\n\n\n\n\n\n$Tarjan$ 强连通分量算法\n\n$Tarjan$ 算法会对有向图 $G$ 进行一次 $DFS$，并维护一个栈，存储那些已经被访问但未被确定 所在强连通分量的顶点。\n$DFS$ 过程中的搜索树会组成原图的一个生成森林。我们考虑强连通分量 $C$ 的第一个被访问 的顶点 $u$，则 $C$ 的所有顶点都在$u$ 在搜索树上的子树中。\n我们希望栈中的所有访问完的顶点都存在一条到达栈中之前某个顶点的路径。如果顶点 $u$ 访问完后不存在这样的路径，则说明 $u$ 以及栈中在 $u$ 之后的点组成了一个强连通分量，而 $u$ 即为这个强连通分量的根。\n算法实现:\n为了判断一个顶点是否存在到达栈中之前某个顶点的路径，我们对每个顶点维护下列变量:\n$dfn(v)$，表示 $DFS$ 到 $v$ 的时间(也就是 $v$ 是第几个访问的顶点)。\n$low(v)$​​，表示从$v$​​ 经过子树中的顶点能到达的栈中顶点中最小的 $dfn$​​。\n\n\n\n\n\n\n$Code$\n\n\nconstexpr int N = 100010;\n\n//adj[v] 存储 v 的所有后继\nstd::vector&lt;int> adj[N];\nint cur = 0;\nstack&lt;int> s;\nint dfn[N],low[N];\nbool inStack[N];\n\nvoid strongConnect(int v) &#123;\n\t//将dfn[v]和low[v] 设置为最小的还未使用的编号\n\tdfn[v] = low[v] = cur++;\n\ts.push(v);\n\tinStack[v] = true;\n\t//访问v的后继\n\tfor(int w:adj[v]) &#123;\n\t\tif(dfn[w] == -1) &#123;\n\t\t\t//w还未被访问过，对其进行递归搜索\n\t\t\tstrongConnect(w);\n\t\t\tlow[v] = min(low[v],low[w]);\n\t\t&#125;\n\t\telse if(inStack[w]) &#123;\n\t\t\t//w 在栈里，因此在当前的强连通分量内\n\t\t\t//如果w不在栈里，则说明w所在的强连通分量之前已经被确定了，因此需要忽略这条边\n\t\t\t//这里可以用low[w] 替换 dfn[w],同样是正确的\n\t\t\t//使用 dfn[w] 的原因是与另外的算法保持一致\n\t\t\tlow[v] = min(low[v],dfn[w]);\n\t\t&#125;\n\t&#125;\n\t//v是当前的强连通分量的根\n\tif(low[v] == dfn[v]) &#123;\n\t\tstd::vector&lt;int> scc;\n\t\tint w;\n\t\tdo &#123;\n\t\t\tw = s.top();\n\t\t\ts.pop();\n\t\t\tinStack[w] = false;\n\t\t\tscc.push_back(w);\n\t\t&#125; while(w != v) ;\n\t\t//scc 即为当前的强连通分量，在这里对其进行必要的操作\n\t&#125;\n&#125;\n\nvoid tarjan(int n) &#123;\n\t//顶点编号 0 ~ n-1\n\tfor(int v = 0;v &lt; n;v++) dfn[v] = -1;\n\tfor(int v = 0;v &lt; n;v++) \n\t\t\tif(dfn[v] == -1) strongConnect(v);\n&#125;\n\n\n\n\n强连通性的应用\n\n最优贸易\n\n$C$​ 国有$n$​个城市$m$​条单向或双向道路连接着这些城市。保证每对城市之间至多只有一条道路。 在每个城市可以以不同的价格购买或出售水晶球。商人阿龙想要从 $1$​ 号城市到达$n$​号城市，并在途中进行至多一次交易，即在某个城市买入水晶球，并在之后经过的某个城市出售。每 个城市和每条道路都可以多次经过。求出阿龙最多可以获得的利润，即售价减去买入价的差值的最大值。如果没有进行交易，则利润为$0$。\n\n$1 \\le n \\le 100000$,$1 \\le m \\le 500000$​​​\n\n在本题中，可以将双向边看成两条有向边。\n\n注意到在一个强连通分量中，可以在城市之间任意移动。我们可以将强连通分量缩成一个 点，保留其中最大和最小的价格，记为 $mx(u)$ 和 $mn(u)$。\n\n缩完点之后，原图变成了一个$DAG$(有向无环图)，我们可以拓扑排序后进行$DP$。设 $f(u)$ 是从点$1$到达点$u$​的最大利润。转移如下\n$$mn(u) \\gets min(mn(u),mn(v)),for each (u,v) \\in E $$\n$$f(u) \\gets max(f(u), f(v)), for each (v, u) ∈ E$$​\n$$f (u) \\gets max(f (u), mx(u) − mn(u))$$\n\n\n\n\n\n\n","slug":"图的强连通性质，桥，割点以及相关应用","date":"2021-09-16T09:40:45.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"005d78720b9e835a238af502516610c0","title":"网络流选讲","content":"网络流选讲网络流定义\n一个有向图，存在源点$S$和汇点$T$，每条边有一个流量，求从$S$到$T$最多能经过多少流量\n$S \\in S’,T \\notin S’$​​,$E’ =  (u,v) | u \\in S’,v \\notin S $​​​​\n最大流量 = 最小割\n\nFord-Fulkerson 算法\n连上反向边之后每次dfs 贪心\n\nDinic 算法\n\n\n\n\n\n\n\n\n\n每次 bfs 先把图分层，然后在分层图上跑增广（多路增广+当前弧优化）。复杂度 $O(|V|^2 |E|)$。\n当然网络流存在最高标号预留推进（$HLPP$）等复杂度更优的做法，但是比较复杂。\n\n最大权闭合子图\n一个有向图，选择一个点就必须选择其后继点，且选择每个点有一个花费或者奖励。求总奖励最大值。\n建$s$连向所有正权点，负权点连向$t$​，假设初始全选所有正权点，减掉最小割就是答案\n\n\n\n最小费用最大流\n每条边有一个费用，每经过 1 的流量就会消耗固定的费用，求最大流时费用最小是多少。\n直接建反向边贪心即可，每次找最短的增广路。由于存在负权，复杂度为 $O(F|V||E|)$。\n\n上下界网络流\n\n\n\n\n\n\n\n\n上下界可行流\n有源汇上下界最小流\n有源汇上下界最大流\n上下界最小费用可行流\n二分图匹配\n给定一个二分图，左侧n个点右侧m个点，求能选出多少条端点不重复的边\n可以用匈牙利算法$O(|V||E|)$解决。也可以用Dinic $O(|E|\\sqrt{|V|})$​\n$n$ - |最大匹配| = |最大独立集|\n\nHall 定理\n判断一个二分图存不存在完美匹配\n内容: 二分图存在完美匹配当且仅当对于任意S，$|N(S)| \\ge |S|$($N(S)$表示从S连出的边另一端构成的点集)\n\n匈牙利算法\n每次贪心的找一条增广路，找不到就无解\n\n二分图最大权匹配KM算法例题\nlg P4001\nlg P2762\nP2763 试题库问题\nP2766 最长不下降子序列问题\nP2774 方格取数问题\n\n万能建图方法\n利用代数推倒来建图\n\n","slug":"网络流选讲","date":"2021-09-16T09:40:18.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"e2573f345f8e369bd93647303f895691","title":"优化技巧","content":"DP优化\n$f_i = min_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$​​\n使用单调队列优化\n\n\n$f_i = sum_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$\n使用前缀和优化\n\n\n$f_i = min_{i - l &lt; j &lt; i}(f_j + p_j w_i) + p_i$\n斜率优化\n\n\n$f_i = sum_{1 &lt; j &lt; i}(f_j + q_{i-j}) + p_i$​​\n分治FFT\n\n\n$f_i = min_{A:j&lt;i,B,a_j &lt; a_i,C:b_j &lt; b_i}(f_j) + p_i$\nCDQ分治\n\n\n$f_i = min_{j&lt;i}{f_i + w(j+1,i)}$​\n决策单调性优化\n\n\n$f_{i,j} = f_{i-1}$\n线段树优化\n\n\n$WQS$二分(凸优化)\n长链剖分\n线段树合并\n矩阵优化（$DDP$）\n齐次线性递推\n$f_i = \\sum_{j = 1}^m f_{i,j} \\cdot a_j$\n\n\n生成函数优化\n\nNOI2007 货币兑换题意\n有$n$天，每天$A$的价值为$a_i,B$的价值为$b_i$\n每天你可以卖掉 $p %$ 的$A$ 和 $B$。也可以花费$k$天买入$A$和$B$，且$ A : B = r_i $\n$a_i,b_i,r_i$均为给定的值，$p,k$可以是任意实数。\n初始你有$S$元，问n天后的最大收益。\n$n \\leq 10^5$​\n题解\n\n首先这个题的p,k可以是任意实数，无法枚举，暴力都打不了\n很容易发现的一个性质是全买全卖存在最优方案\n所以一定是当天把东西全卖掉然后过几天把它全买了，以此类推\n设$f_i$表示第i天能得到最多的钱数，可以发现一定是由$(i-1)$推过来的\n$f_i =a_i \\cdot max_{j&lt;i}(g_j \\cdot r_j + g_j \\cdot \\frac{b_i}{a_i})$​​​​\n\nA\nB\n$C:p_j 单调增,-w_i x $凸包 二分 $O(n logn)$\n$D:p_j x , -w_ix$ CDQ/动态 凸包 $O(n logn)$​\n$f_i = min_{i - l \\le j &lt; i}(f_j + p_j w_i) + q_i$​\n长者一个长度为$n$的排列，有些位置上的数字已经确定了，剩下位置上的数字不确定。你要确定剩下位置上的数字，让得到的排列的最长上生子序列的长度尽量长。 $n \\leq 1e5$\nYet another ioi problem（弱化版）一条链长度为$L$，有$n$个位置上有村庄，你需要选定恰好$k$个位置摆放水井，使得这$n$个村庄到最近的水井的距离和最短。\n$n,k \\leq 1e5,L \\leq 1e9$ \nB输入一颗n哥节点的树，保证每个节点的度数$\\le 16$。\n定义一个路径集合$S$，我们把它称为“好的”，当且仅当这个集合内的路径覆盖了这棵树的所有边，且每条边仅被覆盖一次。\n任务一：要求一个$|S|$最小的好的路径集合（即：使路径条数最小）。输出这个$|S|$。\n任务二：在任务一对基础上（即满足是最小的好的路径集合），要使这个集合中路径长度的$max$最小（定义一颗树上路径长度为边的数量）。输出路径长度的$max$。\n任务三：求满足任务二条件的集合数量。输出$998244353$取模后的值\nCf 1416E考虑dp,f(i,j)表示当前dp到了a_i,b(2i) = j的情况下，合并之后的最小长度。转移显然：$$f(i,j) = [2j \\ne a_i] + min{f(i-1,a_i - j),f(i-1,k) + 1}$$为了方便后面的优化，我们稍微考虑一下dp的定义\n$f(i,j)$表示当前dp到了a_i，b(2i) = j的情况下，最多能使答案减少多少(答案初始为2n)。\n那么方程变为：$$f(i,j) = [2j = a_i] + max(f(i-1,a_i - j)+1,f(i-1,k))$$考虑用数据结构维护dp数组，每次有如下操作：\n1.记t为当前数组里的最大值，然后把大于等于a_i的位置全部删除。\n2.把整个数组反转（reverse）\n3.所有位置的数值和  + x\n","slug":"优化技巧","date":"2021-09-16T09:39:54.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"25ed3aa3446c2c64cf6228f9f4e4f9c4","title":"DP","content":"DPpart1.动态规划的核心概念\n状态\n转移方程\n初始化\n\n实例揭秘本质—斐波那契数列\n$众所周知 斐波那契数列的的递推式是:$ $f_i = f_{i-1} + f_{i-1}(i \\ge 2)$​\n$问题来了，如何来求$$f_n$?\n$这个时候就要用到f_i = f_{i-1} + f_{i-1}来得到他们的值，那么这个时候f_i,f_{i-1},f_{i-2}就对应$$动态规划$$里面的$$状态$\n$所谓的$状态$就指的是你要求$$f_n$​，$那么我们有一些中间结果来得到最后的$$f_n$​，$这些中间的结果，就叫做动态规划里面的$$状态$\n$这些状态之间的关键就叫$$转移方程$\n$最后一个概念$$状态的初始化$，$所谓的状态的初始化就是会存在$$部分状态无法通过转移方程$$求得，在斐波那契数列中$f_0 = 0,f_1 = 1$这个两个值是提前确定好的，如果没有这两个值，那么也不会有后面的值了$\n$所以解决一道普通的动态规划题，我们需要$$设计状态，求转移方程，初始化$$这三个步骤$\n$接下来我们来写一下斐波那契数列的代码来找一下其中的方法$\n$在斐波那契数列中我们可以找出三种方法即:$\n$用别人求自己$(由$f_{i-1} + f_{i-2} \\to f_i$​)\n$用自己求别人$$(由$f_i \\to $$\\begin{cases} f_{i+1} \\ f_{i+2}  \\end{cases}$​​​\n$记忆化搜索$\n\n\n\n\n$在某些题中我们只能用一种方法，因为这些题会利用这两种方法的一种性质$\n\n$Code:$\n#include &lt;bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e6+5;\n\nint n;\nint f[maxn];\nint tag[maxn];\n\n//记忆化搜索\nvoid dfs(int n) &#123;\n\tif(n &lt;= 1) return n;\n\tif(tag[n]) return f[n];\n\ttag[n] = true;//tag[n]代表f[n]有没有被算过\n\tf[n] = dfs(n-1) + dfs(n-2);\n\treturn f[n];\n&#125;\n\nint main() &#123;\n\tscanf(\"%d\",&amp;n);\n\tf[0] = 0,f[1] = 1;\n\t//用别人求自己\n\tfor(int i = 2;i &lt;= n;i++) \n\t\tf[i] = f[i-1] + f[i-2];\n\n\t//用自己求别人\n\tfor(int i = 2;i &lt;= n;i++) &#123;\n\t\tf[i+1] +=f[i];\n\t\tf[i+2] +=f[i];\n\t&#125;\n\n\t//记忆化搜索\n\tdfs(n);\n\treturn 0;\n&#125;\n\nProblem 1:组合数\n$组合数是指从n个东西里面选m个东西的方案数，一般写作C_n^m$\n$给定n和m，求出C_n^m的值是多少$\n$在这个状态里有两种情况$\n$即要选最后一个东西和不选最后一个东西$\n$将两种情况相加即可得到最后的结果$\n$C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$\n\nProblem 2:\n$N * M的方格图，只能向右或者向下，走到右下的方案数？走到右下的最小代价？$\n$1.$$方案数：$\n$用f[i][j]代表走到(i,j)这个位置的方案数$\n$在这个问题中我们就要逐渐注意状态怎么来设计，在很多时候我们的题目要\\求什么我们的状态就要怎么来设计$\n\n\n$所以这个问题的转移方程就是f(i,j) = f(i-1,j) + f(i,j-1)初始化为f(i,0) = f(0,j) = 1$\n$2.$$最小代价$\n$用f[i][j]表示现在走到(i,j)所需要的最小代价$\n$所以转移方程显然是f[i][j] = min(f[i-1][j],f[i][j-1]) + w[i][j]$\n$初始化和1.同$\n\n$拓展$$如果要求不用dp，现在要求直接把走到(n,m)这个点的方案数用一个式子写出来应当是什么样？$\n$Solve$$我们思考如果要从(0,0)走到(n,m)一共有多少步，显然我们需要走n+m步才能到达(n,m)，进而看出往下应该走n步,往右应该走m步，所以，我们可以得出最后的式子为C_{n}^{n+m}$\n$Problem 3$\n$数字三角形$Luogu1216\n$给定一个三角形，让你从最顶上走到最下面$\n$问怎么走能够取得最大价值$\n\n$Solve$\n\n$设f[i][j]为走到(i,j)能取得的最大价值$\n$那么转移方程很显然是f[i][j] = max(f[i-1][j-1],f[i-1][j]) + w[i][j]$\n\nProblem 4\n$将上面的问题改成点权之和$% 100$之后最大    ，求最大价值$\n\n$Solve$\n\n$在这一题中，我们可以发现，按照以前的原则，\\题目问什么我们设什么已经不再好用了，在这题\\中我们如果设f(i,j)代表走到(i,j)和%$ $100$ $的最大值是多少的话，我们会遇到无法用f(i-1,j-1)和 f(i - 1,j)求出真正f(i,j)的值，也就是说这样记录的状态算出来的答\\案是错误的，所以我们不可以这么设计状态。$\n\n$这时候我们引入一个新的方法，就是题目每多一个条件，我的状态就多一个维度,\\所以我们设f(i,j,k)为    走到(i,j)使得点权和(k)$$%$ $100 = k 是否可能$\n\n$和上题一样从(i-1,j-1)或者(i-1,j)走到(i,j)$% 100$ $= k$\n\n$在走到(i,j)之前我们的k \\longleftarrow k - w_{i,j}$\n\n$所以我们的转移方程就是 \\ f[i][j][k] = f[i-1][j-1][k - w_{i,j}]\\ \\  ||\\ \\  f[i][j][k] = f[i-1][j][k - w_{i,j}]$\n\n\nProblem 5$1.最长上升子序列$\n\n$给n个数,a_1,a_2,\\cdots,a_n$\n$希望有 1 \\le b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_m \\le n$\n$使得a_{b_1} &lt; a_{b_2} &lt; a_{b_3} \\cdots &lt; a_{b_m}$ \n$即找到一个最长序列，使得这个数列一直在上升$\n\n$Solve$\n\n$观察目标，我们可以设f[i]代表我找出来的序列最后一个数为a_i时，序列最长能有多长$\n$考虑转移，显然我们需要考虑到a_i下一个数或者前一个数是谁，这样我们就可以得到 \\ f[i] = max_{i \\le j &lt; i\\ \\ \\  &amp;&amp; \\ \\ \\  a_j &lt; a_i}(f[j] + 1)$\n$这个转移的含义为:最后一位是a_i时，枚举一个j这就保证j &lt; i \\ \\ \\  &amp;&amp; \\ \\ \\ a_j &lt; a_i，满足了这两个条件，那么我们再补一个a_i就使它的长度+1，对于所有的j取一个最大值，我们就可以算出f(i)的值了，时间复杂度O(n^2)$\n$这个时间复杂度显然不优，这个时候我们可以用到数据结构优化dp来做$\n$a_1,a_2,a_3,\\cdots,a_n$，$设里面的最小值为1，最大值为m$\n我们可以建一颗$1 ~ m$的线段树\n$这个时候我们可以设a_1作为结尾的最长长度为f[1]，a_2作为结尾的最长长度为f[2]， \\ \\cdots,以此类推$\n$假设现在到了i,我们要算以i为结尾的最长长度，那么我们就要从a_i 到 a_{i-1}中选出a_j\\ ，使得a_j &lt; a_i并且这个f[j]是最大的$\n$将a_1 到 a_{i-1}存到f_1 到 f_{i-1}$\n$我现在要询问a_i的值就是在1 \\le f_i \\le a_i找到f_i的最大值$\n$这样这个问题就转化为了一个查询区间最大值的线段树，这个区间就是1$ ~ $a_i - 1$ $这个区间就是包含了所有&lt; a_i的数，也很容易得到a_i对应的为f_i+1$\n\n$2.求方案$\n\n$根据上面的问题我们再换成求最长上升子序列的方案\n\n$Solve$$所有求方案的DP基本上都是一个套路$$下面用这个题来解决求方案的问题$\n\n$对于这个问题，我们除了要记录原来题目中的状态之外，还需要设一个pre[i],\\ 来记录是从哪个状态转移过来的$\n$例如，pre[10] = 7代表的含义就是f[10]这个位置的状态是从f[7]转移过来的，那么我们可以接着设$\n$pre[7]=5，pre[5]=2,pre[2]=1 ，我们这样就可以倒着走遍历出来最优方案，\\最后的方案就是a_1,a_2,a_5,a_7,a_{10}这个序列$\n\nProblem 6$滑雪$\n\n$n行m列的图$\n$每个格子有高度$\n$可以滑向周围四个比自己矮的格子$\n$最多能划多远$\n\n$Solve$\n$这个问题和迷宫很不一样，迷宫是给定了起点，而这个题目是让你自己选择起点$$通过观察我们可以发现，我们可以将原图按照从大到小或者从小到大排一遍序$$然后我设f(r)为以r为重点最远可以走多远$$现在，我们把问题转化成了一个最长下降子序列，现在转移方程就很显然了$$$f[r] = max_{1 \\le k &lt; r，第r个格子和第k个格子相邻}(f[k])+1$$\nProblem 7$乌龟棋$\n\n$长度为n的格子有权值$\n$m张牌，上面有1-4中其中一个数$\n$使用一张牌往前走几步$\n$最大化经过的路径权值和$\n\n$Solve$\n\n$我们设f[i]为走到了i这个位置,但是我们会发现,无法判断牌被用了多少张,\\也就是说会出现越界,所以我们需要再多加几维状态：设f[i][a][b][c][d]为走\\到i这个位置时，1牌被用了a张，2牌被用了b张，3牌被用了c张，4牌被用了d张$\n$思考复杂度，这个复杂度是O(nm_1m_2m_3m_4) \\approx O(n^5)显然是过不了的$\n$在Problem5中我们讲解了数据结构优化dp,在这里我们讲解另外一种优\\化dp的方式$$冗余状态优化$\n$观察状态设计,我们通过简单的推出一个式子$$$i = a+2b+3c+4d$$$所以这五维状态我们任意删除一个状态即可,这样我们就把时间复杂度\\由O(n^5)优化到了O(m^4)了$\n\n区间DP\n$以区间作为dp的状态，每次区间[l,r]$\n$即设f(i,j)表示区间[i，r]的最优解$\n\n$Problem1$\n$合并石子$\n\n$有n堆石子,a_1,a_2,a_3,\\cdots,a_n$\n$需要做n-1次操作，每次操作需要合并相邻两对石子$\n$例如,合并a_2和a_3就是a_2 + a_3然后就变成了n-1堆石子a_1,a_2+a_3,\\cdots,a_n，且合并\\这两堆石子的代价为a_2+a_3$\n$现在希望你合并出来a_1+a_2+a_3+\\cdots+a_n，并且最小代价是多少$\n\n$Solve$\n\n$这道题是典型的区间dp题,当你看到有相邻的操作的时候，我们首先就要考虑区间dp。$\n$首先很容易想到的一个性质就是，如果a_l,a_r被合并了，那么a_l,a_{l+1},\\cdots,a_{r-1},a_r \\都被合并$\n$想到了如下性质之后我们来讲一下关于区间dp的三要素$\n$状态：一般设计成f[l][r] 代表把第l$ ~ $r 合并为\\cdots$\n$转移：思考f[l][r]怎么求，在合并l$ ~ $r的前一次操作是把l$ ~ $k$和$k+1$ ~ $r$$的合并成一堆$，$那么合并成这两堆石子的代价分别是，f[l][k]和f[k+1][r]，\\所以这个转移方程是$    $$f[l][r] = min_{l \\le k \\le r}(f[l][r],f[l][k] + f[k+1][r] + sum[r] - sum[l-1])$$\n$初始化：首先肯定要让i \\rightarrow i 花费的代价为0，故f[i][i] = 0$\n\n\n\n$Problem2$\n\n$n个矩阵$\n$m_1:a_1 \\times a_2，m_2:a_2 \\times a_3，m_3: a_3 \\times a_4,\\cdots,m_n:a_n \\times a_{n+1}$\n$把n个矩阵乘起来，可以进行结合律，计算m_2和m_3这两个矩阵的代价是a_2 \\times a_3 \\times a_4，随后这两个矩阵变成(m_2 \\times m_3):a_2 \\times a_4$\n$现在的问题是，把这些矩阵加一些括号，使这些矩阵代价最小$\n\n$Solve$\n\n$基于上一题的思想，我们可以设f[l][r]为将m_l$ ~ $m_r这些矩阵乘起来所需要的最小代价$\n$枚举一个中间的断点k，把a_l$ ~ $a_k和a_{k+1}$ ~ $a_r分别算出，最后把这两个矩阵乘起来即可$\n$所以这个转移方程就是$$$f[l][r] = min_{l \\le k &lt; r}(f[l][k] + f[k+1][r] + a[l] * a[k+1] * a[r+1])$$\n$所以这一题我们也用区间dp搞定了$\n\n$Problem3$\n\n$给出一个的只有()[]四种括号组成的字符串$\n$求出最多能够选出多少个括号满足完全匹配$\n\n$Solve$\n\n$这个题的转移方法和上面的不太一样，我们设f[l][r]代表从l - r最多能取出多少个括号进行匹配$\n$思考f[l][r]和f[l+1][r]的关系,例如f[l+1][r]我们可以取10个括号进行匹配，那么f[l][r]也可以取十个括号$\n$同理，如果f[l][r-1]取了12个括号，那f[l][r]也可以取12个括号$\n$所以f[l][r] = max(f[l][r] || f[l][r-1])$\n$思考还有没有其他的情况，显然还有一种情况是如果l - r为:(()),1-4这四个括号可以选4个括号,因为除了在l - r-1和l+1 - r这两个区间内部以外，还有一种方案是从l+1 - r-1，在l和r匹配相同的括号，再在l+1 - r-1中匹配括号$\n$也就是说f[l][r] = max(f[l][r] || f[l][r-1] || f[l+1][r-1]+2)最后一维代表l和r能够匹配$\n\n树形DP\n以树上的节点作为dp状态，记 d(u)表示u的整颗子树的的信息，从儿子的状态转移过来\n\n状压DP数位DP$\\le n$的满足条件的数字个数\n$\\le 10^n$ 的满足条件的数字个数​\n有不超过$n$个十进制位\n$d_{i,j}$表示从高到低的前i位已经选择完，且最低的位为$j$的方案数\n转移:枚举$i+1$位填的数字$k$，要求，$|j-k|\\ge 2$，从$d(i,j)$转移到$d(i+1,k)$​​​\nP2235$f(n) = \\begin{cases} f(1) = 1 \\ f(3) = 3 \\ f(2n) = f(n) \\ f(4n+1) = 2f(2n+1) - f(n)\\f(4n + 3) = 3 f(2n+1) - 2f(n) \\end{cases}$\n\n这个函数代表的意思是把n的二进制串翻转\n\n所以，很容易想到数位$dp$\n\n设$d(i,c1,c2)$​表示考虑j前i为和后i位，c1\n\n枚举回文数的第i+1位是k，转移到$d(i+1,c1’,c2’)$\n\n\nP3281The Last\n求$\\sum_{i = l}^r\\lgroup ^{a+i} _b  \\rgroup c^i \\mod p$​\n\n$p \\le 1e5 , c &lt; p, l, r, a, b \\le 1e18$\n\n$p$为质数\n\n\n","slug":"DP","date":"2021-09-16T09:38:51.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"ec60c99e46e2ba013a49cda28261b89b","title":"生成函数的运算与组合数计数问题.md","content":"生成函数的运算与组合数计数问题摘要\n​    本文介绍了处理形式幂级数的一些高效算法，并在生成函数的运算过程中加以应用，从而解决一系列组合计数问题。\n目录$1$.引言\n$2$.多项式与形式幂级数\n​    $2.1$ 多项式\n​    $2.2$ 多项式的基本运算\n​    $2.3$ 形式幂级数\n$3$.组合计数问题\n​    $3.1$ 组合对象\n​    $3.2$ 普通生成函数\n​    $3.3$ 指数生成函数\n$4$.乘法逆元\n$5$.乘法逆元的应用\n$6$. 对数与指数运算\n​    $6.1$ 复合运算\n​    $6.2$ 形式导数\n​    $6.3$​ 对数函数与指数函数\n\n​            $6.3.1$ 对数函数的计算\n​            $6.3.2$ 指数函数的计算\n​    $6.4$ 牛顿迭代法\n​    $6.5$ $k$次幂的计算\n$7$ 集合的计数\n​    $7.1$ 有标号集合的计数\n​    $7.2$ 无标号集合的计数\n$8$ 环的计数\n​    $8.1$ 有标号环的计数\n​    $8.2$ 无标号环的计数\n$9$ 复合运算\n​    $9.1$ 复合与复合逆\n​    $9.2$ $Lagrange$反演\n$10$ 二元生成函数\n$11$ 结语\n\n$1$​ 引言​    组合计数问题是信息学竞赛中常见的一类问题，而生成函数往往是解决这类问题的重要工具。近年来，信息学竞赛中出现了这样一类计数问题，不仅需要选手根据题意对生成函数进行分析与推导，还要求使用高效的算法完成各类多项式运算，才能优化求解的时间复杂度。本文将对这一类问题进行进一步分析与总结。\n​    本文第2，3节回顾了一些需要用到的基本知识。其中第2节提到了几种熟知的多项式乘法算法，以及算法实现时需要注意的地方；第3节引入了组合对象的生成函数的概念，并分析了生成函数加法、乘法的组合意义。\n​    第4节介绍了求解形式幂级数乘法逆元的牛顿迭代法，这一算法是后文许多算法的基础。第5节中的例题对该算法进行了简单应用。\n​    第6节介绍了形式幂级数的对数，指数函数的求解算法。\n​    第7，8节分析了集合、环这两类常见组合模型的计数方法，并对第6节中的算法进行了简单应用。\n​    第9节简单介绍与复合运算相关的算法和定理。\n​    第10节介绍了运用二元生成函数解决问题的技巧。\n$2$ 多项式与形式幂级数$2.1$ 多项式​        多项式是我们熟知的数学概念。一个关于x的多项式可以写成$$A(x) = \\sum_{i = 0}^{n-1} a_ix^i$$的形式，其中系数$a_i$均为某个环$R$中$^①$​的元素。这些多项式组成多项式环$R[x]$。\n​        非零多项式$A(x)$的次数定义为其最高次项的系数，记为$deg A(x)$。\n$2.2$ 多项式的基本运算​        设参与运算的多项式中最高次数为$n$。那么多项式的加法、减法显然可以在$O(n)$时间内计算。\n\n①一般指可交换环，可以是复数域$C$、实数域$R$、整数环$Z$、剩余类环$Z/nZ$等。\n\n​        我们关心的是两个多项式的乘积。朴素的计算方法需要$O(n^2)$时间，并不够优秀。\n​        一中优化方法是分治乘法$^②$，它的原理是利用$$(Ax^m + B)(Cx^m + D) \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =ACx^{2m} + ((A + B)(C + D) - AC - BD)x^m + BD$$减少乘法次数进行递归。复杂度为$O(n^{\\log_23}) = O(n^{1.585})$。\n​        分治乘法的劣势在于复杂度较高，但它不涉及除法，所以对环$R$没有特别的要求。\n​        此外，当运算在模2意义下进行时，我们也可以利用位运算加速，使得算法常数减小到原来的$1/32$。\n​        另一种做法是$FFT^③$​。它利用单位根的性质，实现了多项式的系数与点值表示之间的快速转化。时间复杂度是$O(n logn)$。\n​        为了使用$FFT$，$R$需具有$2^k$次单位根($2^k \\ge 2n$)，且存在2的乘法逆元。当系数在复数域内时，单位根总能找到，但计算时容易出现精度问题。\n​        需要注意到的是，信息学竞赛中涉及的计数问题往往要求答案模一个大质数$p$(如$1e9+7$或$998244353 = 7 \\times 17 \\times 2^{23} +1$等等)后输出。这样的好处包括：每次算术运算的时间可以视作$O(1)$，不存在精度问题，且大多数情况可以支持除法(只要在问题规模范围内，除数都远小于$p$，存在乘法逆元)。因此本文中假设所有运算都在$F_p$下进行。\n​        在模$p$​意义下进行$FFT$​时，若满足$2^k|\\varphi(p) = p -1$​，则可取$p$​的原根$g$​，并用$g^{\\frac{p-1}{2^k}}$​作为单位根；否则，将系数视作$Z$​的元素进行运算后再对$p$​取模。这时，相乘得到的系数大小不超过$np^2$​​，只要取若干个便于$FFT$​的大质数分别进行运算，再用中国剩余定理（$CRT$）还原系数即可。\n$2.3$ 形式幂级数​        一个多项式仅有有限项的系数是非零的。若去掉这一限制，可将其推广为形式幂级数$$A(x) = \\sum_{i \\ge 0} a_ix_i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2,2)$$————————————————————\n②详见http://en.wikipedia.org/wiki/Karatsuba_algorithm\n③详见http://en.wikipedia.org/wiki/Discrete_Fourier_transform\n\n它们组成了形式幂级数中环$R[[x]]$。\n​        此定义中，$x$仅作为一个符号，而不用具体的数值带入运算，故不必考虑与幂级数敛散性有关的问题。\n​        我们用$[x^n]A(x)$表示$A(x)$的$n$次项系数$a_n$。\n​        形式幂级数的加减法与乘法也可与多项式运算类似定义：$$A(x) = \\sum_{i \\ge 0} a_ix^i，B(x) = \\sum_{i \\ge 0} b_ix^i，\\ \\ \\ \\ \\ \\ \\ (2.3) \\A(x) \\pm B(x) = \\sum_{i \\ge 0} (a_i \\pm b_i)x^i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\  \\ \\ (2.4) \\A(x)B(x) = \\sum_{k \\ge 0} (\\sum_{i+j = k}a_ib_j)x^k \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2.5)$$​        实际运算时，通常只需保留次数不超过$n - 1$的项进行计算，并将多余的项舍去(即在模$x^n$意义下计算)。因此加减法的复杂度为$O(n)$，乘法的复杂度为$O(nlogn)$。\n$3$组合计数问题$3.1$ 组合对象​        组合计数问题是一类常见的问题。这类问题中一般定义了一类组合对象$A$​，它可能是满足某一性质的树、图、串等对象的集合；其中每个对象$a \\in A$​都被定义了大小$size(a)\\in n$​的对象$a$的数量是有限的，计作$A_n$。我们的任务通常为求出$A_n$的数值。\n​        根据不同的问题要求，组合对象可以分为有标号和无标号两类。下面简单以无向图为样例解释它们的区别：\n​        n个点的标号图中，每个顶点都被赋予了$1,2,\\cdots，n$中的唯一标号；然而在无标号图中，每个顶点的地位是没有区别的。如图所示，$n = 3$时，无标号的简单无向图共有四种，而有标号的简单无向图有$8$种。\n\n\n\n$3.2$ 普通生成函数​        数列$A_0,A_1,\\cdots$的普通生成函数（$Ordinary\\ Generating\\ Function，OGF$）定义为形式幂级数$$A(x) = \\sum_{i \\ge 0} A_ix^i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.1)$$​        $A$是一类无标号对象，则$A$的普通生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的普通生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        对于两类无标号对象$A,B$，定义一类新的对象$C = A \\cup B$，若$A，B$交集为空，则$C$的生成函数即为$$C(x) = A(x) + B(x).        \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.2)$$​        再来考虑$A,B$的笛卡尔积$D = A \\times B$，其中$D$的每个元素$d$都是一个二元组$(a,b)$，其中$a \\in A,b \\in B$，并定义$size(d) = size(a) + size(b)$。则有$$D_k = \\sum_{i + j = k}A_iB_j，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3,3)$$于是$D$的$OGF$即为$$D(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.4)$$这一操作实现了$A$中元素和$B$中元素的拼接。\n$3.3$ 指数生成函数​        数列$A_0，A_1,\\cdots$的指数生成函数（ $Exponential\\ Generating Function，EGF$​）定义为形式幂级数$$A(x) = \\sum_{i \\ge 0} A_i\\frac{x_i}    {i!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.5)$$\n\n指数生成函数在处理有标号问题时更加便捷。对于一类有符号对象$A$，$A$的指数生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的指数生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        给定两类有标号对象$A,B$，对于它们的并集$C = A \\cup B$，同样有$$C(x) = A(x) + B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.6)$$​        现在考虑有标号对象的拼接。给定两个对象$a,b$​，设$size(a) = n$​ ，$size(b) = m$​，他们分别带有$1,2,\\cdots,n$​和$1,2,\\cdots,m$​的标号。为将$a,b$​拼接得到$c$​，需给$c$​分配$1,2,\\cdots,n+m$​的标号。规定重新分配时需要保持标号的原有相对顺序，则有$$\\binom{n+m}{n} = \\frac{(n+m)!}{n!m!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.7)$$种方法\n​        因此。若将两类带标号对象$A,B$拼接得到$D$，则有$$D_k = \\sum_{i + j = k} A_iB_j \\frac{k!}{i!j!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.8)$$从而$D$的$EGF$也具有$$D(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.9)$$的形式。\n$4$ 乘法逆元​        当$A(x)B(x) = 1$时，称$A(x)，B(x)$互为乘法逆元，可以写作$A(x) = B(x)^{-1}   = 1 / B(x)$。除以一个形式幂级数，就相当于乘上它的乘法逆元。\n​        例如，$$\\frac{1}{1 - x} = 1 + x + x^2 + x^3 + \\cdots.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.1)$$根据这一等式可得，若数列$a_0,a_1,\\cdots$的普通生成函数为$A(x)$，令$s_n = \\sum_{i = 0}^{n}a_i$，那么$s_0,s_1,\\cdots$的普通生成函数为$A(x)/(1-x)$。\n​        再结合二项式系数的递推性质，可得$$\\frac{1}{(1-x)^{n+1}} = \\sum_{i \\ge 0} \\binom{n+i}{n}x^i \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.2)$$\n\n​        接下来介绍，在给定$A(x)$时，如何求出$A(x)$的乘法逆元$B(x)$。\n​        可以证明，$A(x)$存在乘法逆元的充要条件是$A(x)$的常数项存在乘法逆元。必要性由$([x^0]A(x))([x^0]B(x)) = 1$​可得。而当$A(x)$的常数项可逆时，即可根据乘法的定义($2.5$)按顺序求出$[x^1]B(x),[x^2]B(x),\\cdots$的值，于是此时乘法逆元存在且唯一。同时，我们得到了一个求出乘法逆元前$n$项的$O(n^2)$朴素算法。\n​        下面介绍一个用$O(nlogn)$时间计算乘法逆元的算法，它的本质是牛顿迭代法。\n​        首先求出$A(x)$的常数项的逆元$b$，并令$B(x)$的初始值为$b$。\n​        假设已求满足$$A(x)B(x) \\equiv 1\\pmod  {x^n} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.3)$$的$B(x)$，则$$A(x)B(x) - 0 \\equiv 0 \\pmod {x^n}， \\(A(x)B(x) - 1)^2 \\equiv 0 \\pmod {x^{2n}}， \\A(x)(2B(x) - B(x)^2 A(x)) \\equiv 1 \\pmod {x^{2n}}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.4)$$我们用$o(n logn)$时间计算出$2B(x) - B(x)^2A(x)$，并将它赋值给$B(x)$进行下一轮迭代。每迭代一次，$B(x)$的有效项数$n$都会增加一倍。于是该算法的时间复杂度为$$T(n) = T(n/2) + O(n logn) = O(nlogn).$$\n$5$  乘法逆元的应用例题1(序列计数).你有若干种不同颜色的骨牌，其中大小为$1 \\times i$的骨牌共有$a_i$种。每种骨牌都可以无限量使用。用骨牌不重叠地铺满一排$1 \\times n$的方格，共有几种方法？($a_i,n \\le 10^5$​)\n​        我们枚举使用的骨牌数量$k$。设$A(x) = \\sum_{i \\ge 0}a_ix_i$，则根据生成函数的乘法的意义，容易知道此时的答案为$[x^n]A(x)^k$。所以总方法数目为$$[x^n]\\sum_{k \\ge 0} A(x) = [x^n]\\frac{1}{1 - A(x)}. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.1)$$于是只需计算$1 - A(x)$的乘法逆元即可，时间复杂度$O(n logn)$。    \n\n​        一般地，对于这一类组合对象$A$，由$A$的元素组成的序列定义一类新的组合对象$B$，则$B$的生成函数为$$B(x) = \\frac{1}{1 - A(x)}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.2)$$这一结论对于无标号$(OGF)$、有标号$(EGF)$的情况都成立。\n例题2(预处理$Bernoulli$).\n对于所有$0 \\le i \\le n-1$求出$B_i$。($n \\le 10^5$)\n$Bernoulli数B_0,B_1,\\cdots的指数生成函数为$\n$B(x) = \\sum_{i \\ge 0} B_i\\frac{x^i}{i!} \\=\\frac{x}{e^x -1} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.3) \\=(\\sum_{i \\ge 0}\\frac{x^i}{(i+1)!})^{-1}.$这样，只要求一次乘法逆元即可。\n例题3.$字符集大小为m。给定一个长度为k的字符串s，求出所有长为n的串中，不包含子串s\\的共有几个$\n$\\ \\ 假定串的下标都从1开始$\n$\\ \\ 考虑DP，用f_i表示有多少种方法填前i个字符，使得第一次匹配上串s的位置是$ $[i-k+1,i]。当i &lt; k时,f_i = 0;当i \\ge k$，\n$$f_i = m^{i-k} - \\sum_{0 \\le j \\le i - k}f_im^{i-k-j} - \\sum_{d &gt; 0,d \\in C} f_{i-d}，$$\n$其中集合C定义为{d \\ge 0 | s[d+1,k] = s[1,k-d]}。$\n$这个DP方程的含义是，末尾k的字符与串s相同，前i-k位字符可以任意确定，但为了保证i - k + 1是第一次匹配上的位置，需要从中减去之前已经匹配过的情况。减去的第一项是这次匹配与上一次没有重叠的情况，第二项是与上次出现重叠的情况，为此需要先用KMP算法求出C的集合。$\n$为了优化这个DP，考虑f的生成函数f(x) = \\sum_{i \\ge 0} f_i x^i。令C(x) = \\sum_{d \\in C^{x^d}}，则可由DP方程写出$\n$f(x) = \\frac{x^k}{1 - mx} - \\frac{x^k f(x)}{1 - mx} - f(x)(c(x) - 1)，$\n\n$定义见$http://en.wikipedia.org/wiki/Bernoulli%5fnumber\n\n","slug":"生成函数的运算与组合数计数问题-md","date":"2021-09-16T09:32:38.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-09-16T08:56:10.901Z","categories_index":"","tags_index":"","author_index":"Aurora"}]