[{"id":"ec60c99e46e2ba013a49cda28261b89b","title":"生成函数的运算与组合数计数问题.md","content":"生成函数的运算与组合数计数问题摘要\n​    本文介绍了处理形式幂级数的一些高效算法，并在生成函数的运算过程中加以应用，从而解决一系列组合计数问题。\n目录$1$.引言\n$2$.多项式与形式幂级数\n​    $2.1$ 多项式\n​    $2.2$ 多项式的基本运算\n​    $2.3$ 形式幂级数\n$3$.组合计数问题\n​    $3.1$ 组合对象\n​    $3.2$ 普通生成函数\n​    $3.3$ 指数生成函数\n$4$.乘法逆元\n$5$.乘法逆元的应用\n$6$. 对数与指数运算\n​    $6.1$ 复合运算\n​    $6.2$ 形式导数\n​    $6.3$​ 对数函数与指数函数\n\n​            $6.3.1$ 对数函数的计算\n​            $6.3.2$ 指数函数的计算\n​    $6.4$ 牛顿迭代法\n​    $6.5$ $k$次幂的计算\n$7$ 集合的计数\n​    $7.1$ 有标号集合的计数\n​    $7.2$ 无标号集合的计数\n$8$ 环的计数\n​    $8.1$ 有标号环的计数\n​    $8.2$ 无标号环的计数\n$9$ 复合运算\n​    $9.1$ 复合与复合逆\n​    $9.2$ $Lagrange$反演\n$10$ 二元生成函数\n$11$ 结语\n\n$1$​ 引言​    组合计数问题是信息学竞赛中常见的一类问题，而生成函数往往是解决这类问题的重要工具。近年来，信息学竞赛中出现了这样一类计数问题，不仅需要选手根据题意对生成函数进行分析与推导，还要求使用高效的算法完成各类多项式运算，才能优化求解的时间复杂度。本文将对这一类问题进行进一步分析与总结。\n​    本文第2，3节回顾了一些需要用到的基本知识。其中第2节提到了几种熟知的多项式乘法算法，以及算法实现时需要注意的地方；第3节引入了组合对象的生成函数的概念，并分析了生成函数加法、乘法的组合意义。\n​    第4节介绍了求解形式幂级数乘法逆元的牛顿迭代法，这一算法是后文许多算法的基础。第5节中的例题对该算法进行了简单应用。\n​    第6节介绍了形式幂级数的对数，指数函数的求解算法。\n​    第7，8节分析了集合、环这两类常见组合模型的计数方法，并对第6节中的算法进行了简单应用。\n​    第9节简单介绍与复合运算相关的算法和定理。\n​    第10节介绍了运用二元生成函数解决问题的技巧。\n$2$ 多项式与形式幂级数$2.1$ 多项式​        多项式是我们熟知的数学概念。一个关于x的多项式可以写成$$A(x) = \\sum_{i = 0}^{n-1} a_ix^i$$的形式，其中系数$a_i$均为某个环$R$中$^①$​的元素。这些多项式组成多项式环$R[x]$。\n​        非零多项式$A(x)$的次数定义为其最高次项的系数，记为$deg A(x)$。\n$2.2$ 多项式的基本运算​        设参与运算的多项式中最高次数为$n$。那么多项式的加法、减法显然可以在$O(n)$时间内计算。\n\n①一般指可交换环，可以是复数域$C$、实数域$R$、整数环$Z$、剩余类环$Z/nZ$等。\n\n​        我们关心的是两个多项式的乘积。朴素的计算方法需要$O(n^2)$时间，并不够优秀。\n​        一中优化方法是分治乘法$^②$，它的原理是利用$$(Ax^m + B)(Cx^m + D) \\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =ACx^{2m} + ((A + B)(C + D) - AC - BD)x^m + BD$$减少乘法次数进行递归。复杂度为$O(n^{\\log_23}) = O(n^{1.585})$。\n​        分治乘法的劣势在于复杂度较高，但它不涉及除法，所以对环$R$没有特别的要求。\n​        此外，当运算在模2意义下进行时，我们也可以利用位运算加速，使得算法常数减小到原来的$1/32$。\n​        另一种做法是$FFT^③$​。它利用单位根的性质，实现了多项式的系数与点值表示之间的快速转化。时间复杂度是$O(n logn)$。\n​        为了使用$FFT$，$R$需具有$2^k$次单位根($2^k \\ge 2n$)，且存在2的乘法逆元。当系数在复数域内时，单位根总能找到，但计算时容易出现精度问题。\n​        需要注意到的是，信息学竞赛中涉及的计数问题往往要求答案模一个大质数$p$(如$1e9+7$或$998244353 = 7 \\times 17 \\times 2^{23} +1$等等)后输出。这样的好处包括：每次算术运算的时间可以视作$O(1)$，不存在精度问题，且大多数情况可以支持除法(只要在问题规模范围内，除数都远小于$p$，存在乘法逆元)。因此本文中假设所有运算都在$F_p$下进行。\n​        在模$p$​意义下进行$FFT$​时，若满足$2^k|\\varphi(p) = p -1$​，则可取$p$​的原根$g$​，并用$g^{\\frac{p-1}{2^k}}$​作为单位根；否则，将系数视作$Z$​的元素进行运算后再对$p$​取模。这时，相乘得到的系数大小不超过$np^2$​​，只要取若干个便于$FFT$​的大质数分别进行运算，再用中国剩余定理（$CRT$）还原系数即可。\n$2.3$ 形式幂级数​        一个多项式仅有有限项的系数是非零的。若去掉这一限制，可将其推广为形式幂级数$$A(x) = \\sum_{i \\ge 0} a_ix_i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2,2)$$————————————————————\n②详见http://en.wikipedia.org/wiki/Karatsuba_algorithm\n③详见http://en.wikipedia.org/wiki/Discrete_Fourier_transform\n\n它们组成了形式幂级数中环$R[[x]]$。\n​        此定义中，$x$仅作为一个符号，而不用具体的数值带入运算，故不必考虑与幂级数敛散性有关的问题。\n​        我们用$[x^n]A(x)$表示$A(x)$的$n$次项系数$a_n$。\n​        形式幂级数的加减法与乘法也可与多项式运算类似定义：$$A(x) = \\sum_{i \\ge 0} a_ix^i，B(x) = \\sum_{i \\ge 0} b_ix^i，\\ \\ \\ \\ \\ \\ \\ (2.3) \\A(x) \\pm B(x) = \\sum_{i \\ge 0} (a_i \\pm b_i)x^i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\  \\ \\ (2.4) \\A(x)B(x) = \\sum_{k \\ge 0} (\\sum_{i+j = k}a_ib_j)x^k \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2.5)$$​        实际运算时，通常只需保留次数不超过$n - 1$的项进行计算，并将多余的项舍去(即在模$x^n$意义下计算)。因此加减法的复杂度为$O(n)$，乘法的复杂度为$O(nlogn)$。\n$3$组合计数问题$3.1$ 组合对象​        组合计数问题是一类常见的问题。这类问题中一般定义了一类组合对象$A$​，它可能是满足某一性质的树、图、串等对象的集合；其中每个对象$a \\in A$​都被定义了大小$size(a)\\in n$​的对象$a$的数量是有限的，计作$A_n$。我们的任务通常为求出$A_n$的数值。\n​        根据不同的问题要求，组合对象可以分为有标号和无标号两类。下面简单以无向图为样例解释它们的区别：\n​        n个点的标号图中，每个顶点都被赋予了$1,2,\\cdots，n$中的唯一标号；然而在无标号图中，每个顶点的地位是没有区别的。如图所示，$n = 3$时，无标号的简单无向图共有四种，而有标号的简单无向图有$8$种。\n\n\n\n$3.2$ 普通生成函数​        数列$A_0,A_1,\\cdots$的普通生成函数（$Ordinary\\ Generating\\ Function，OGF$）定义为形式幂级数$$A(x) = \\sum_{i \\ge 0} A_ix^i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.1)$$​        $A$是一类无标号对象，则$A$的普通生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的普通生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        对于两类无标号对象$A,B$，定义一类新的对象$C = A \\cup B$，若$A，B$交集为空，则$C$的生成函数即为$$C(x) = A(x) + B(x).        \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.2)$$​        再来考虑$A,B$的笛卡尔积$D = A \\times B$，其中$D$的每个元素$d$都是一个二元组$(a,b)$，其中$a \\in A,b \\in B$，并定义$size(d) = size(a) + size(b)$。则有$$D_k = \\sum_{i + j = k}A_iB_j，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3,3)$$于是$D$的$OGF$即为$$D(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.4)$$这一操作实现了$A$中元素和$B$中元素的拼接。\n$3.3$ 指数生成函数​        数列$A_0，A_1,\\cdots$的指数生成函数（ $Exponential\\ Generating Function，EGF$​）定义为形式幂级数$$A(x) = \\sum_{i \\ge 0} A_i\\frac{x_i}    {i!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.5)$$\n\n指数生成函数在处理有标号问题时更加便捷。对于一类有符号对象$A$，$A$的指数生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的指数生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        给定两类有标号对象$A,B$，对于它们的并集$C = A \\cup B$，同样有$$C(x) = A(x) + B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.6)$$​        现在考虑有标号对象的拼接。给定两个对象$a,b$​，设$size(a) = n$​ ，$size(b) = m$​，他们分别带有$1,2,\\cdots,n$​和$1,2,\\cdots,m$​的标号。为将$a,b$​拼接得到$c$​，需给$c$​分配$1,2,\\cdots,n+m$​的标号。规定重新分配时需要保持标号的原有相对顺序，则有$$\\binom{n+m}{n} = \\frac{(n+m)!}{n!m!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.7)$$种方法\n​        因此。若将两类带标号对象$A,B$拼接得到$D$，则有$$D_k = \\sum_{i + j = k} A_iB_j \\frac{k!}{i!j!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.8)$$从而$D$的$EGF$也具有$$D(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.9)$$的形式。\n$4$ 乘法逆元​        当$A(x)B(x) = 1$时，称$A(x)，B(x)$互为乘法逆元，可以写作$A(x) = B(x)^{-1}   = 1 / B(x)$。除以一个形式幂级数，就相当于乘上它的乘法逆元。\n​        例如，$$\\frac{1}{1 - x} = 1 + x + x^2 + x^3 + \\cdots.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.1)$$根据这一等式可得，若数列$a_0,a_1,\\cdots$的普通生成函数为$A(x)$，令$s_n = \\sum_{i = 0}^{n}a_i$，那么$s_0,s_1,\\cdots$的普通生成函数为$A(x)/(1-x)$。\n​        再结合二项式系数的递推性质，可得$$\\frac{1}{(1-x)^{n+1}} = \\sum_{i \\ge 0} \\binom{n+i}{n}x^i \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.2)$$\n\n​        接下来介绍，在给定$A(x)$时，如何求出$A(x)$的乘法逆元$B(x)$。\n​        可以证明，$A(x)$存在乘法逆元的充要条件是$A(x)$的常数项存在乘法逆元。必要性由$([x^0]A(x))([x^0]B(x)) = 1$​可得。而当$A(x)$的常数项可逆时，即可根据乘法的定义($2.5$)按顺序求出$[x^1]B(x),[x^2]B(x),\\cdots$的值，于是此时乘法逆元存在且唯一。同时，我们得到了一个求出乘法逆元前$n$项的$O(n^2)$朴素算法。\n​        下面介绍一个用$O(nlogn)$时间计算乘法逆元的算法，它的本质是牛顿迭代法。\n​        首先求出$A(x)$的常数项的逆元$b$，并令$B(x)$的初始值为$b$。\n​        假设已求满足$$A(x)B(x) \\equiv 1\\pmod  {x^n} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.3)$$的$B(x)$，则$$A(x)B(x) - 0 \\equiv 0 \\pmod {x^n}， \\(A(x)B(x) - 1)^2 \\equiv 0 \\pmod {x^{2n}}， \\A(x)(2B(x) - B(x)^2 A(x)) \\equiv 1 \\pmod {x^{2n}}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.4)$$我们用$o(n logn)$时间计算出$2B(x) - B(x)^2A(x)$，并将它赋值给$B(x)$进行下一轮迭代。每迭代一次，$B(x)$的有效项数$n$都会增加一倍。于是该算法的时间复杂度为$$T(n) = T(n/2) + O(n logn) = O(nlogn).$$\n$5$  乘法逆元的应用例题1(序列计数).你有若干种不同颜色的骨牌，其中大小为$1 \\times i$的骨牌共有$a_i$种。每种骨牌都可以无限量使用。用骨牌不重叠地铺满一排$1 \\times n$的方格，共有几种方法？($a_i,n \\le 10^5$​)\n​        我们枚举使用的骨牌数量$k$。设$A(x) = \\sum_{i \\ge 0}a_ix_i$，则根据生成函数的乘法的意义，容易知道此时的答案为$[x^n]A(x)^k$。所以总方法数目为$$[x^n]\\sum_{k \\ge 0} A(x) = [x^n]\\frac{1}{1 - A(x)}. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.1)$$于是只需计算$1 - A(x)$的乘法逆元即可，时间复杂度$O(n logn)$。    \n\n​        一般地，对于这一类组合对象$A$，由$A$的元素组成的序列定义一类新的组合对象$B$，则$B$的生成函数为$$B(x) = \\frac{1}{1 - A(x)}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.2)$$这一结论对于无标号$(OGF)$、有标号$(EGF)$的情况都成立。\n例题2(预处理$Bernoulli$).\n对于所有$0 \\le i \\le n-1$求出$B_i$。($n \\le 10^5$)\n$Bernoulli数B_0,B_1,\\cdots的指数生成函数为$\n$B(x) = \\sum_{i \\ge 0} B_i\\frac{x^i}{i!} \\=\\frac{x}{e^x -1} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.3) \\=(\\sum_{i \\ge 0}\\frac{x^i}{(i+1)!})^{-1}.$这样，只要求一次乘法逆元即可。\n例题3.$字符集大小为m。给定一个长度为k的字符串s，求出所有长为n的串中，不包含子串s\\的共有几个$\n$\\ \\ 假定串的下标都从1开始$\n$\\ \\ 考虑DP，用f_i表示有多少种方法填前i个字符，使得第一次匹配上串s的位置是$ $[i-k+1,i]。当i &lt; k时,f_i = 0;当i \\ge k$，\n$$f_i = m^{i-k} - \\sum_{0 \\le j \\le i - k}f_im^{i-k-j} - \\sum_{d &gt; 0,d \\in C} f_{i-d}，$$\n$其中集合C定义为{d \\ge 0 | s[d+1,k] = s[1,k-d]}。$\n$这个DP方程的含义是，末尾k的字符与串s相同，前i-k位字符可以任意确定，但为了保证i - k + 1是第一次匹配上的位置，需要从中减去之前已经匹配过的情况。减去的第一项是这次匹配与上一次没有重叠的情况，第二项是与上次出现重叠的情况，为此需要先用KMP算法求出C的集合。$\n$为了优化这个DP，考虑f的生成函数f(x) = \\sum_{i \\ge 0} f_i x^i。令C(x) = \\sum_{d \\in C^{x^d}}，则可由DP方程写出$\n$f(x) = \\frac{x^k}{1 - mx} - \\frac{x^k f(x)}{1 - mx} - f(x)(c(x) - 1)，$\n\n$定义见$http://en.wikipedia.org/wiki/Bernoulli%5fnumber\n\n","slug":"生成函数的运算与组合数计数问题-md","date":"2021-09-16T09:32:38.000Z","categories_index":"","tags_index":"","author_index":"Aurora"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2021-09-16T08:56:10.901Z","categories_index":"","tags_index":"","author_index":"Aurora"}]