[{"id":"bf5652b06f25669829372da351ef6ae7","title":"素数筛","content":"素数筛素数概念:学素数筛之前,我们要先引入素数的概念,那么,何为素数:\n\n\n\n\n\n\n\n\n\n除了1和自身之外,没有其他约数的数称为素数(也叫质数)\n有其他约数的数称为合数\n特别的1既不是质数,也不是合数\n判定:那么我们来思考,如何判断一个数是否是质数\n自然我们可以枚举从小到大每个数看看能否被整除,复杂度$O(n)$\n但我们很容易就会发现一个事实,如果x是a的约数,那么 $\\frac{a}{x}$也是a的约数,因此,我们只需要枚举到$\\sqrt{a}$即可。时间复杂度$O(\\sqrt{a})$\n代码实现(暴力)\n//核心代码\nbool isPrime(int a)&#123;\n    if(a &lt; 2) return false;\n    for(int i = 2; i &lt;= a;i++)\n        if(a % i == 0) return false;\n    return true;\n&#125;\n\n代码实现(优化)\n//核心代码\nbool isPrime(int a)&#123;\n    if(a &lt; 2) return false;\n    for(int i = 2;i * i &lt; a;i++)&#123;\n        if(a % i == 0) return false;\n    &#125;\n    return true;\n&#125;\n\n素数筛法:如果我们想要知道 $\\leq n$的所有素数呢\n埃式筛法一个自然的想法是我们对,每个小于等于n的每个数,进行一次判定。复杂度$O(n\\sqrt{n})$\n这样时间复杂度显然太高了,所以我们要优化一下\n考虑到一个数的大于自身的倍数一定是合数，利用这个结论，我们可以避免不必要的判断\n如果我们从小到大考虑每个数，然后同时把当前这个数的所有(比自己大的)倍数记为合数,那么运行结束的时候,没有被标记过的就全是素数了。\n这就是$Eratosthenes$筛法,时间复杂度是$O(n\\log\\log{n})$\n代码实现\n//核心代码\n    for(int i = 2;i &lt;= n;i++)\n        if(!vis[i])&#123;\n            pri[++cnt] = i;\n            for(int j = i * 2;j &lt;= n;j++)\n                vis[j] = 1;\n        &#125;\n\n欧拉筛法我们发现，埃式筛法似乎会某些数标记了很多次其为合数。再考虑优化掉这些步骤。如果能让每个数都只被标记一次,那么时间复杂度就可以降到$O(n)$了\n这种筛法叫做欧拉(Euler)筛法。\n\n//核心代码\nvoid Euler()&#123;\n    for(int i = 2;i &lt; maxn;i++)&#123;\n        if(!vis[i]) pri[++cnt] = i;\n        for(int j = 0;j &lt; cnt;j++)&#123;\n            if(1ll * i * pri[j]) break;\n            vis[i * pri[j]] = 1;\n        if(i % pri[j] == 0) break;//i 之前被 pri[j] 筛过了\n//由于 pri 里面的质数是从小到大的 所以 i 乘上其他的质数的结果一定也是\n//pri[j]的倍数 它们都被筛过了 就不要再筛过了,就不需要筛了,所以这里直接break掉就好了\n        &#125;\n        \n    &#125;\n&#125;\nThe End","slug":"素数筛","date":"2021-09-16T12:49:29.000Z","categories_index":"","tags_index":"知识点,数学,算法,素数,筛法","author_index":"TheLight"},{"id":"1109bb51ef1fe7597b5b03d20a7a9ddd","title":"矩阵","content":"在学习矩阵之前我们需要学习快速幂运算\n快速幂前言快速幂的作用就是求$x^y$的值\n思想也非常简单以前我们的$pow$函数时间复杂度为$O(y)$的这个函数是通过每次的乘法运算实现的例如:$x^{37}$ = $x \\cdot x \\cdot x \\cdot x \\cdot x …… \\cdot x$进行x的三十七次乘法运算,这样时间复杂度显然不优\n\n原理:而快速幂的思想是将$x^{37}$分成$(x^{18})^2\\cdot x$再分成$((x^9)^2)^2\\cdot x$再分成$(((x^4)^2 \\cdot x)^2)^2\\cdot x$一直这样分下去,显然这样时间复杂度就被降到了$O(log y)$,这样的代码也非常的好实现\n代码:\n//核心代码\nint mul(int x,int y)&#123;//O(y)\n    if(y == 0) return 1;//如果指数为0时,结果是1\n    int v = mul(x,y/2);//递归\n    v = 1ll * v * v//有可能会爆int所以1ll*强制类型转换一下\n    if(y % 2 != 0) v = v * x;//奇数需要多乘一个x\n    return v;//返回值\n&#125;\n看得出来这个算法还有一些地方算的挺慢的,那么我们可以通过位运算来优化这个函数\n$\\frac{y}{2}$可以理解为:y的二进制数向左移$1$位\n$y$ % $2$可以理解为将$y$分解为二进制的每一位为$a_1,a_2,a_3,……,a_n$,而$y$%$2$最后的值只有0和1两个数,当y%2为0的时候是偶数,否则是奇数。我们通过进一步研究可以发现$y$%$2$与$a_n$是相等也就是$y$%$2$就相当于$y$的二进制位的个位;$y$%$2\\ne 0$也就是相当于$y$&amp;$1$\n通过这些位运算我们可以把时间复杂度降低到$O(log y)$\n代码:\n//核心代码\nint mul(int x,int y)&#123;//时间复杂度O(log y)\n    if(y == 0) return 1;\n    int v = mul(x,y >> 1);\n    v = 1ll * v * v;\n    if(y&amp;1) v = 1ll * v * x;\n    return v;\n&#125;\n矩阵简介矩阵是高等数学中常用的一个代数工具,在OI中也非常常见。\n所谓的矩阵就是一个n行m列的数表\n\\begin{pmatrix}\n    a_{11} & a_{12} & …… & a_{1m} \\\\\n    a_{21} & a_{22} & …… & a_{2m} \\\\\n    …… & …… & …… & …… \\\\\n    a_{n1} & a_{n2} & …… & a_{nm} \\\\\n\\end{pmatrix}像这样一个$n\\times m$的东西,我们就把他叫做一个$n \\times m$的矩阵。实际上,我们可以把矩阵理解为一个$n \\cdot m$的二位数组\n运算那么矩阵能干嘛呢？我们接下来引入矩阵的运算法则\n加减法例如这里有两个$n \\times m$的矩阵:A和B\n\\begin{pmatrix}\n        a_{11} & …… & a_{1m} \\\\\n        a_{n1} & …… & a_{nm} \\\\\n\\end{pmatrix}\\begin{pmatrix}\n    b_{11} & …… & b_{1m} \\\\\n    b_{n1} & …… & b_{nm} \\\\\n\\end{pmatrix}A \\pm B = \\begin{pmatrix}\n    a_{11} \\pm b_{11} & a_{12} \\pm b_{12} & …… & a_{1m} \\pm b_{1m} \\\\\n    …… & …… & …… & …… & \\\\\n    a_{n1} \\pm b_{n1} & a_{n2} \\pm b_{n2} & …… & a_{nm} \\pm b_{nm}  \n\\end{pmatrix}乘法我们有一个大小为$n \\times m$的矩阵A,还有一个大小为$m \\times k$列的矩阵(只有第一个矩阵 = 第二个矩阵的行数的时候才能进行矩阵乘法)\nA(n\\times m) \\times B(m \\times k) = C(n \\times k)例如:\n这里有一个$2 \\times 2$的矩阵A和一个$2 \\times 3$矩阵B\n\\begin{bmatrix}\n    1 & 2\\\\\n    3 & 4 \\\\\n\\end{bmatrix}\n\\times \\begin{bmatrix}\n    1 & 2 & 3 \\\\\n    2 & 3 & 3 \\\\\n\\end{bmatrix}那么矩阵C的i行j列的求法就是:取出A的第i行，取出B的第j列，假设这i行和j列的数字数目都为m,然后我们把这m个数对应相乘，然后再对它求一个和就是矩阵这个位置的值矩阵C的值就等于:\nC = \\begin{bmatrix}\n    5 & 8 & 9 \\\\\n    11 & 18 & 21 \\\\\n\\end{bmatrix}性质:1.不具有交换律\n$A \\times B \\ne B \\times A$\n2.有结合律\n$(A \\cdot B) \\cdot C = A \\cdot (B \\cdot C)$\n3.有分配律(左、右)\n左分配律:$A\\cdot(B \\pm C) = A \\cdot B \\pm A \\cdot C$\n右分配律:$(A \\pm B) \\cdot C = A\\cdot C \\pm B\\cdot C$\n作用看完了矩阵的定义和运算,自然而然有一个问题——矩阵有什么用？\n斐波那契数列有一个数列$f$,其中$f_0 = 0；f_1 = 1；i \\ge 2；f_i = f_{i - 1} + f_{i - 2}$\n把这个数列写出来就是$0、1、1、2、3、5、8、13、21、34、55、89、……$\n现在的问题是给出一个$n$,我希望求斐波那契数列的第$n$项对$1e9+7$取模的答案\n很容易想到纯暴力的方法的复杂度为$O(n)$即暴力求出f数列每一个位置的值\n可是如果n的范围扩大到$10^18$呢,那么我们就需要用到矩阵乘法来进行这个运算\n那么我们怎么来算呢:\n我们可以先定义一个1\\times 2 的矩阵A里面存放：\n\\begin{bmatrix}\n    f_i & f_{i-1}\\\\\n\\end{bmatrix}再定义一个2 \\times 2的矩阵B里面存放\\begin{bmatrix}\n    1 & 1 \\\\\n    1 & 0 \\\\ \n\\end{bmatrix}那么A \\times B得到的矩阵C就是\\begin{bmatrix}\n    f_i + f_{i - 1} & f_i\\\\\n\\end{bmatrix} 即:\\begin{bmatrix}\n    f_{i+1} & f_i \\\\\n\\end{bmatrix}代码实现:\n#include &lt;bits/stdc++.h>\n\n#define ll long long\n\nll n;\nint p;\n\nstruct matrix&#123;\n    int n,m;\n    int z[5][5];\n    matrix() &#123;n = m = 0;memset(z,0,sizeof(z));&#125;\n&#125;;\n\ninline ll read();\nmatrix mul(matrix x,int y);\n\nmatrix operator*(const matrix &amp;m1,const matrix &amp;m2)&#123;//O(8)\n    matrix m3;\n    m3.n = m1.n; m3.m = m2.m;\n    for(int i = 1;i &lt;= m3.n;i++)//选择矩阵A的行\n        for(int j = 1;j &lt;= m3.m;j++)//选择矩阵B的列\n            for(int k = 1;k &lt;= m1.m;k++)//枚举每一行的m个数字\n                m3.z[i][j] = (m3.z[i][j] + 1ll * m1.z[i][k] * m2.z[k][j]) % p;\n    return m3;\n&#125;\n\nint main()&#123;\n    std::ios::sync_with_stdio(false);\n    std::cin >> n >> p;\n    matrix A,B;\n    A.n = 1,A.m = 2;\n    B.n = 2;B.m = 2;\n    A.z[1][1] = 1;A.z[1][2] = 0;\n    B.n = 2;B.m = 2;\n    B.z[1][1] = 1;B.z[1][2] = 1;B.z[2][1] = 1;B.z[2][2] = 0;\n    A = A * mul(B,n-1);//O(logn)\n    std::cout &lt;&lt; A.z[1][1];\n    return 0;\n&#125;\n\ninline ll read()&#123;\n    int s = 0,w = 1;char ch = getchar();\n    while(ch &lt; '0' || ch > '9')&#123;if(ch == '-')w = -1;ch = getchar();&#125;\n    while(ch >= '0' &amp;&amp; ch &lt;= '9')&#123;s = s*10+ch-'0',ch = getchar();&#125;\n    return s * w;\n&#125;\n\nmatrix mul(matrix x,int y)&#123;//O(logn)\n    if(y == 0)&#123;\n        matrix z;\n        z.n = z.m = x.n;\n        for(int i = 1;i &lt;= z.n;i++)\n            z.z[i][i] = 1;\n        return z;\n    &#125;\n    matrix v = mul(x,y >> 1);\n    v =  v * v;\n    if(y&amp;1) v = v * x;\n    return v;\n&#125;\nThe End","slug":"矩阵","date":"2021-09-16T12:48:18.000Z","categories_index":"","tags_index":"知识点,数学,矩阵,快速幂","author_index":"TheLight"},{"id":"650830902f7d1f1c6412622da735e342","title":"生成树问题","content":"定义:给定一张n个点m条边的图,我们要从m条边当中选出n-1条边,使得选出来的n-1条边能和n个点组成一棵树求最小生成树的解决方法思路:\n我们可以在这张图中找到一条权值最小的边1 —&gt;1—&gt; 2\n那么我们来思考,最小生成树中是否一定包含权值最小的那一条边\n答案是,一定,那么我们怎么来思考这个问题呢\n我们可以用反证法来证明(假设下图就是上图的最小生成树(其实不是))\n\n一开始我们假设最小的边不在最小生成树上,那么肯定有一条边会连接两个点(当然不是树上的一条边)例如:连接4 -&gt; 9\n连接之后我们会发现1 -&gt; 2 -&gt; 4 -&gt; 9 -&gt; 7 -&gt; 3 -&gt; 1形成了一个环,\n但由于我们自己连接的4 -&gt; 9 是最小的一条边,所以我们环上的每一条边都比我们连接的这条边要大;那么我们再来想,我们任意删除一条除了自己连接的边 例如:删掉3 -&gt; 7 那么剩下的这个图形是不是一棵树\n它是一颗树对吧,因为我们如果不删3 -&gt; 7这条边的话它就是一个章鱼图,而章鱼图只要随便删除环上一条边,那么他就又变回一颗树了\n我们把删去的3 -&gt; 7这条边的权值设为v1,把自己连接的4 -&gt; 9这条边的权值设为v2,设原来的总权值为t:\n那么我们新的这棵树的和为:t - v1 + v2\n∵v2是所有边中最小的 ∴ v1 &gt; v2 ∴t - v1 + v2 &lt; t\nKruscal算法:基于最小生成树中一定包含权值最小的那一条边 我们可以从权值最小的那一条边开始选 那么我们可以把这张图按照从小到大排序 同时,我们如果想要选一条边那么我们要判断这张图会不会形成环\n基于上述思路,我们可以得出Kruscal的核心问题为:我们从小到大看这条边能不能选,如果能选就选上,如果不能选就把它跳过\n但如果我们要判断加入一条边会不会形成环,那么我们需要用到并查集\n//完整代码\n#include &lt;cstdio>\n#include &lt;cstdlib>\n#include &lt;cstring>\n#include &lt;algorithm>\n\nusing namespace std;\n\nconst int maxn = 1e5+10;\nconst int maxm = 2e5+10;\n\nint n,m,f[maxn];//f为并查集\n\nstruct edge &#123;\n    int s,e,d;//起点 终点 长度\n&#125;ed[maxm];\n\nbool cmp (edge a,edge b) &#123;\n    return a.d &lt; b.d;\n&#125;\n\nint get (int p) &#123;\n    if (f[p] == p)return p;\n    else return f[p] = get(f[p]);\n&#125;\n\nint main() &#123;\n    scanf(\"%d%d\",&amp;n,&amp;m);\n    for(int a = 1;a &lt;= m;a++)\n\t\tscanf(\"%d%d%d\",&amp;ed[a].s,&amp;ed[a].e,&amp;ed[a].d);\n    sort(ed+1,ed+m+1,cmp);\n    for(int a = 1;a &lt;= n;a++) f[a] = a;\n    \n    int ans = 0;\n    for(int a = 1;a &lt;= m;a++)//时间复杂度为O(mlogm)\n    &#123;\n        int s = ed[a].s,e = ed[a].e,d = ed[a].d;\n        int f1 = get(s);\n        int f2 = get(e);\n        if(f1 != f2) &#123;\n            f[f1] = f2;//进行合并\n            ans+=d;\n        &#125;\n    &#125;\n    printf(\"%d\\n\",ans);\n    return 0;\n&#125;\n次小生成树算法思路:1.求最小生成树    2.枚举非树边    3.用倍增求用非树边替换哪条数边","slug":"生成树问题","date":"2021-09-16T12:47:44.000Z","categories_index":"","tags_index":"知识点,图论,算法,最小生成树","author_index":"TheLight"},{"id":"4c36a9d56d2b10957f85952e1a221749","title":"最近公共祖先","content":"最近公共祖先概念:对于有根树T的两个结点u、v，最近公共祖先LCA(T,u,v)表示一个结点x，满足x是u和v的祖先,且x的深度尽可能大。(即找两个节点共同的父节点)\n例:6和7的LCA是2，3和7的LCA是1\nLCA的求法:1.暴力让他们一步步向上找//处理出now所有儿子节点的深度与父亲\nvoid dfs(int now)\n&#123;\n\tfor (int p=first[now];p!=0;p=ed[p].next)\n\t&#123;\n\t\tint e=ed[p].e;//now -- e\n\t\tif (e!=f[now])\n\t\t&#123;\n\t\t\tdepth[e]=depth[now]+1;\n\t\t\tf[e]=now;\n\t\t\tdfs(e);\n\t\t&#125;\n\t&#125;\n&#125;\n\n//暴力求LCA\nint get_lca(int p1,int p2)//O(n)\n&#123;\n\tif (depth[p1]&lt;depth[p2]) swap(p1,p2);\n\twhile (depth[p1]>depth[p2])\n\t\tp1=f[p1];\n\twhile (p1!=p2)\n\t\tp1=f[p1],p2=f[p2];\n\treturn p1;\n&#125;\n//完整代码\n#include&lt;cstdio>\n#include&lt;cstdlib>\n#include&lt;cstring>\n\nusing namespace std;\n\nconst int maxn=100010;\nconst int maxm=200010;\n\nint n,en,first[maxn];\n\nint f[maxn],depth[maxn];\n\nstruct edge\n&#123;\n\tint e;\n\tint next;\n&#125;ed[maxm];\n\nvoid add_edge(int s,int e)\n&#123;\n\ten++;\n\ted[en].e=e;\n\ted[en].next = first[s];\n\tfirst[s] = en;\n&#125;\n\nvoid dfs(int now)\n&#123;\n\tfor (int p=first[now];p!=0;p=ed[p].next)\n\t&#123;\n\t\tint e=ed[p].e;//now -- e\n\t\tif (e!=f[now])\n\t\t&#123;\n\t\t\tdepth[e]=depth[now]+1;\n\t\t\tf[e]=now;\n\t\t\tdfs(e);\n\t\t&#125;\n\t&#125;\n&#125;\n\nint get_lca(int p1,int p2)//O(n)\n&#123;\n\tif (depth[p1]&lt;depth[p2]) swap(p1,p2);\n\twhile (depth[p1]>depth[p2])\n\t\tp1=f[p1];\n\twhile (p1!=p2)\n\t\tp1=f[p1],p2=f[p2];\n\treturn p1;\n&#125;\n\nint main()\n&#123;\n\tscanf(\"%d%d\",&amp;n,&amp;m);\n\tfor (int a=1;a&lt;n;a++)\n\t&#123;\n\t\tint s,e;\n\t\tscanf(\"%d%d\",&amp;s,&amp;e);\n\t\tadd_edge(s,e);\n\t\tadd_edge(e,s);\n\t&#125;\n\n\tdepth[1]=1;\n\tdfs(1);\n\n\tfor (int a=1;a&lt;=m;a++)//O(nm)\n\t&#123;\n\t\tint p1,p2;\n\t\tscanf(\"%d%d\",&amp;p1,&amp;p2);\n\t\tprintf(\"%d\\n\",get_lca(p1,p2));\n\t&#125;\n\treturn 0;\n&#125;\n\n\n\n显然这样时间复杂度很高,所以我们引入倍增求LCA\n2.倍增求LCA所谓倍增就是按2的倍数跳着找，也就是1,2,4,8,16……，在这里我们要考虑从大到小跳(因为我们从小到大跳,就会出现回溯这种情况,因为我们不一定能精准的跳，而从大到小跳可以避开这种情况)//预处理\nvoid dfs(int now)//处理出now所有儿子节点的深度与父亲\n&#123;\n    for(int p = first[now];p!=0;p = ed[p].next)\n    &#123;\n        int e = ed[p].e;\n        if (e != f[now][0])\n        &#123;\n            depth[e] = depth[now] + 1;\n            f[e][0] = now;\n            for (int i = 1;i &lt;= 18;i++)\n            &#123;\n                f[e][i] = f[f[e][i-1]][i-1];\n            &#125;\n            dfs(e);\n        &#125;\n    &#125;\n&#125;\n//求LCA\nint get_lca(int p1,int p2)//O(n)\n&#123;\n    if(depth[p1] &lt; depth[p2])swap(p1,p2);\n    for(int i = 1;i &lt;= 18;i++)\n    &#123;\n        if (depth[f[p1][i]] >= depth[p2]) p1 = f[p1][i];\n    &#125;\n    if(p1 == p2)return p1;\n    for(int i = 18 ;i >= 0;i--)\n    &#123;\n        if(f[p1][i]!=f[p2][i])p1=f[p1][i],p2 = f[p2][i];\n    &#125;\n    return f[p1][0];\n&#125;\n//完整代码\n#include &lt;cstdio>\n#include &lt;cstring>\n#include &lt;cstdlib>\n#include &lt;algorithm>\n\nusing namespace std;\n\nconst int maxn = 1e5+10;\nconst int maxm = 2e5+10;\n\nint n,m,en,first[maxn];\n\nint f[maxn][20],depth[maxn];//f[i]代表i向上走i的j次方步会走到哪里 depth[i]代表i号点的深度\n\nstruct edge\n&#123;\n    int e;\n    int next;\n&#125;ed[maxm];\n\nvoid add_edge(int s,int e)\n&#123;\n    en++;\n    ed[en].e=e;\n    ed[en].next = first[s];\n    first[s] = en;\n&#125;\n\nvoid dfs(int now)//处理出now所有儿子节点的深度与父亲\n&#123;\n    for(int p = first[now];p!=0;p = ed[p].next)\n    &#123;\n        int e = ed[p].e;\n        if (e != f[now][0])\n        &#123;\n            depth[e] = depth[now] + 1;\n            f[e][0] = now;\n            for (int i = 1;i &lt;= 18;i++)\n            &#123;\n                f[e][i] = f[f[e][i-1]][i-1];\n            &#125;\n            dfs(e);\n        &#125;\n    &#125;\n&#125;\n\nint get_lca(int p1,int p2)//O(n)\n&#123;\n    if(depth[p1] &lt; depth[p2])swap(p1,p2);\n    for(int i = 1;i &lt;= 18;i++)\n    &#123;\n        if (depth[f[p1][i]] >= depth[p2]) p1 = f[p1][i];\n    &#125;\n    if(p1 == p2)return p1;\n    for(int i = 18 ;i >= 0;i--)\n    &#123;\n        if(f[p1][i]!=f[p2][i])p1=f[p1][i],p2 = f[p2][i];\n    &#125;\n    return f[p1][0];\n&#125;\n\nint main()\n&#123;\n    scanf(\"%d%d\",&amp;n,&amp;m);\n    for(int i = 1;i &lt;= m;i++)\n    &#123;\n        int s,e,d;\n        scanf(\"%d%d\",&amp;s,&amp;e);\n        add_edge(s,e);\n        add_edge(e,s);\n    &#125;\n\n    depth[1] = 1;\n    dfs(1);\n\n    for(int i = 1;i &lt;= m;i++)//O(mn)\n    &#123;\n        int p1,p2;\n        scanf(\"%d%d\",&amp;p1,&amp;p2);\n        printf(\"%d\\n\",get_lca(p1,p2));\n    &#125;\n    return 0;\n&#125;\n\n","slug":"最近公共祖先","date":"2021-09-16T12:46:49.000Z","categories_index":"","tags_index":"知识点,图论,算法,倍增,LCA","author_index":"TheLight"},{"id":"665dc3c56673e4afdc879c20d4cbcde8","title":"最短路径问题","content":"最短路径问题最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。\n\n松弛操作在讲松弛操作之前，我们要先明确一个事实\n那就是在计算两点间的最短路时，通常不仅仅会算出两点间的最短路，而会把许多点之间的最短路一同算出来\n那……\n这是为什么呐？？？\n就是为了松弛操作。\n松弛操作，从字面上解释就是指将两点间较长的路径进行替换，换为一条较短的路径。\n换句话说，就是当你发现这两个地方之间还有更短的路可以走时，用这条路径来替换已知的较短路径，直到不能替换为止。\n这时的 “已知的较短路径”，就是我们要求解的最短路。\n松弛操作的基本模式是这样的\n\n\n\n\n\n\n\n\n\n对于任意两点u,v 目前的最短路，我们可以用$u,w$与$w,v $之间的最短路去更新,$u,v$的最短路，即$s(u,v) = min(s(u,v) , s(u,w) + s(w,v))$\n在计算单源最短路时,若$u$,$v$目前的最短路为$s(u,v)$,则对于v所直接连到的节点w,有$s(u,v) = min(s(u,v) ,s(u,w) + s(w,v))$\n至于为什么这样做，原因还是在于单源 —— 因为我们在计算单源最短路时，只关心 到其他点的最短路，因此 到 的最短路就极不易求。因此，我们换为两点间的直接距离来减小时间复杂度。\n这就是我们为什么要计算其他点最短路 —— 为了松弛操作的顺利进行。\n种类:1.$Floyd$\n2.$Dijkstra + heap$\n3.$Bellman-Ford$\n4.$SPFA$\n1) $唯一的多元最短路算法—Floyd$众所周知，$Floyd$ 算法是一种极其简单的算法\n但同时，它也是最快的多元最短路算法\n$Floyd$ 算法基于 $DP$,说白了,就是枚举中间点,不停地进行松弛操作来更新最短路。\n代码实现也很容易,但时间复杂度比较高,为O($n^3$)\n\n//核心代码:\n    for(int i = 1;i &lt;= n;i++)//O(n&lt;sup>3&lt;/sup>)\n    &#123;\n        for(int j = 1;j &lt;= n;j++)\n        &#123;\n            for(int k = 1;k &lt;= n;k++)\n            &#123;\n                dist[j][k] = min(dist[j][k],dist[j][i]+dist[i][k]);\n            &#125;\n        &#125;   \n    &#125;\n\n$2) Dijkstra$众所周知，$Dijkstra$ 是一种单源最短路算法，可以用于没有负边权的最短路问题。\n而且 $Dijkstra$ 基于贪心，相对来说比较好想一些。\n\n\n\n\n\n\n\n\n\n1.选择一个边作为起始边。\n2.遍历与起始点相连的所有边,寻找出一条最短的记录下来。\n3.把这条边的另一个端点作为起始点，然后循环。\n\n//核心代码\nvoid dijkstra(int s)\n&#123;\n    memset(dist,0x3f3f3f3f,sizeof(dist));\n    dist[s] = 0;\n    for(int i = 1; i &lt;= n;i++)//O(n&lt;sup>2&lt;/sup> + m)\n    &#123;\n        int p = -1;\n        for(int j = 1;j &lt;= n;j++)\n        &#123;\n            if(!right[j] &amp;&amp; (p == -1 || dist[j] &lt; dist[p])) p = j;\n        &#125;\n        right[p] = true;\n        for(int j = first[p]; j;j = ed[j].next)\n        &#123;\n            int e = ed[j].e,d = ed[j].d;\n            dist[e] = min(dist[e],dist[p]+d);\n        &#125;\n    &#125;\n&#125;\n\n$Dijkstra + heap$优化不难发现，当我们在 dis 数组中寻找最小值时，需要一个个进行遍历。\n因此，我们可以将其放入优先队列（堆）中，直接弹出。\n优化后的时间复杂度为$O(nlogn)$\n\n//核心代码\nstruct rec\n&#123;\n    int p,d;\n    rec()&#123;&#125;//空的构造函数\n    rec(int a,int b)&#123;p = a;d = b;&#125;//两个参数的构造函数\n&#125;;\n\nbool operator&lt;(const rec &amp;a,const rec &amp;b)\n&#123;\n    return a.d > b.d;\n&#125;\n\npriority_queue&lt;rec> heap;\n\nvoid dijkstra(int s)\n&#123;\n    memset(dist,0x3f3f3f3f,sizeof(dist));\n    dist[s] = 0;\n    for(int i = 1; i &lt;= n;i++)\n    &#123;\n        heap.push(rec(i,dist[i]));\n    &#125;\n    for(int i = 1;i &lt;= n;i++)//O((n+m)log(n+m))\n    &#123;\n        while (right[heap.top().p])\n            heap.pop(); \n        rec x = heap.top();\n        heap.pop();\n        int p = x.p;\n        right[p] = true;\n        for(int j = first[p]; j;j = ed[j].next)\n        &#123;\n            int e = ed[j].e,d = ed[j].d;\n            if (dist[e] > dist[p] + d)\n            &#123;\n                dist[e] = dist[p] + d;\n                heap.push(rec(e,dist[e]));\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n$4) Bellman-Ford$这个算法基本上死了,如果有负边权的情况我们可以使用$SPFA$算法$SPFA$是基于$Bellman-Ford$改进过的算法\n\n//核心代码\n    for(int i = 1;i &lt; n;i++)//O(nm)\n        for(int j = 1;j &lt;= m;j++)\n            dist[e[j]] = min(dist[e[j]],dist[s[j]]+d[j]);\n$5) SPFA$$SPFA$ 与 $Dijkstra$ 一样，是一种单源最短路算法\n而且……\n$SPFA$ 可以处理负边权\n那么\n为什么 $SPFA$ 可以处理负边权呐？？？\n众所周知，$SPFA$ 是一个基于队列的算法，它的实现流程大概是这样的\n\n\n\n\n\n\n\n\n\n1.初始化 $dis$ 数组，将其全部赋值为一个很大的数\n2.选一个点做起始点，并将起始点丢入队列。\n3.改变所有与起始点相连点的最短路，并做出标记。\n4.弹出起始点，把刚刚标记的所有点作为起始点丢进队列，并循环，直到队列为空为止。\nSPFA 在面对负边权时，不会像 $Dijkstra$ 一样进行无脑循环，而是加入队列。\n因此，SPFA 是可以处理负边权的。但 $SPFA$ 不能处理负权回路\n时间复杂度为,$O(km)$其中,$m$为边数，而$k$为每个节点的平均入队次数，一般为 2。\n\nvoid spfa(int s)\n&#123;\n    memset(dist,0x3f3f3f,sizeof(dist));\n    dist[s]  = 0;\n    queue&lt;int> q;\n    q.push(s);\n    inque[s] = true; //判断一个点是否在队列里面\n\n    while(q.size())\n    &#123;\n        int now = q.front();\n        q.pop();\n        inque[now] = false;\n\n        for(int p = first[now] ; p != 0; p = ed[p].next)//枚举边表\n        &#123;\n            int e = ed[p].e,d = ed[p].d;//now ---> e 长度为d\n            if(dist[e] > dist[now])\n            &#123;\n                dist[e] = dist[now] + d;\n                if(!inque[e])\n                &#123;\n                    inque[e] = true;\n                    q.push(e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n如何选择算法1.判断是多源最短路还是单元最短路，如果是多源则选择Floyd,否则详见第二条。2.判断有没有边权，边权是否    ≥    0，如果边权 ≥ 0 则选择 Dijkstra + Heap , 如果存在边权 ＜ 0，则一定是SPFA。特别鸣谢本文中的松弛操作以及最短路径的原理来源于xht大佬的博客:\nPayphone-X的最短路总结篇\nThe End","slug":"最短路径问题","date":"2021-09-16T12:44:06.000Z","categories_index":"","tags_index":"图论,算法,最短路,Dijkstra,SPFA,Bellman-Ford,三角不等式","author_index":"TheLight"},{"id":"efce904e2fde083966eb57ba4b88b825","title":"扩展欧几里得","content":"扩展欧几里得算法概况我们之前讲的gcd算法叫做欧几里得算法，下面介绍拓展欧几里得算法(Extended Euclidean algorithm,EXGCD),从它的名字就可以看出来，它是欧几里得算法的拓展。扩欧算法求的是二元一次不定方程$ax + by = gcd(a,b)$的一组整数解\n假设我们已经求出 $bx’ + (a mod b)y’ = gcd(b,a mod b)$的一组解，我们想要求出$ax+by=gcd(a,b)$的解。我们已经知道$gcd(a,b) = gcd(b,a mod b)$。联立两个式子，可得$ax + by =bx’+(a mod b)y’$。\n又因为$a mod b = a - \\lfloor{\\frac{a}{b}\\rfloor} \\times b$所以，\n$ax+by=bx’+ay’ - \\lfloor\\frac{a}{b}\\rfloor \\times b =ay’+b(x’-\\lfloor \\frac{a}{b} \\rfloor \\times y’)$\n于是我们得到了一组解:$x = y’,y = x’ - \\lfloor \\frac{a}{b} \\rfloor \\times y’$\n因此我们可以像求gcd那样往下递归，直到$a=1，b=0，$此时解为$x = 1，y = 0$,然后根据递归的结果求解即可。\n代码实现\n//核心代码\nint exgcd(int a,int b,int &amp;x,int &amp;y)&#123;\n    // x 和 y表示直接引用，表示修改操作可以影响到代入的数\n    if(!b)&#123;\n        x = 1; y = 0; return a;\n    &#125;\n    int d = exgcd(b , a % b , x , y);\n    int t = x;\n    x = y;\n    y = t - (a / b) * y;\n    return d;\n&#125;\n\nint a,b,x,y;\n\nint main()\n&#123;\n    scanf(\"%d%d\",&amp;a,&amp;b);\n    int d = exgcd(a,b,x,y);//求得的结果存在x,y里,函数返回的结果为gcd(a,b)\n    printf(\"%d %d %d\\n\",d,x,y);\n    return 0;\n&#125;\nThe End","slug":"扩展欧几里得","date":"2021-09-16T12:43:04.000Z","categories_index":"","tags_index":"数学,拓展欧几里得,算法","author_index":"TheLight"},{"id":"7ff326fdf142ec1868a8e7b87c57157c","title":"基础数据结构","content":"基础数据结构链表:因为数组的插入和删除很慢，所以我们引入了链表这个概念,那么链表是什么样的一个数据结构呢?\n定义:每一个元素都有箭头指向下一个元素,同理每一个元素都有箭头指向上一个元素,即 依靠箭头把n个数连接起来的一个数据结构\n\n代码实现(包括插入和删除)\ncpp\n\n//核心代码\nstruct node&#123;\n    int next,pre;\n    int v;\n&#125;z[maxn];\n\n//i -> k\n//i -> j -> k\nvoid insert(int i,int j)//把编号为j的节点插入到编号为i的节点后面\n&#123;//O(1)\n    int k = z[i].next;\n    z[i].next = j;\n    z[j].pre = i;\n    z[k].pre = j;\n    z[j].next = k;\n&#125;\n\n//j -> i -> k\n//j -> k\nvoid del(int i)\n&#123;//O(1)\n    int j = z[i].pre;\n    int k = z[i].next;\n    z[j].next = k;\n    z[k].pre = j;\n&#125;\n\n\n\n\n\n队列所谓的队列实际上的模型来源于排队,可以理解为前面有一个柜台,有若干的人在排队\n模型的操作1.来一个新的人\n如果来一个新的人那么他会在队列的右边即一个元素从右边进入\n2.走掉一个人\n如果走掉一个人,那么走掉的这个人在左边即一个元素从左边扔掉\n基于上述两个操作我们可以得出:先进入队列的元素会先被删除 即队列的先进先出性质\n代码实现手写队列\n//核心代码\nstruct queue&#123;\n    int head = 1,tail = 0;\n    int z[maxn];\n\n    void push(int x)//加入一个元素\n    &#123;\n        tail++;\n        z[tail] = x;\n    &#125;\n\n    void pop()//删除一个元素\n        head++;\n\n    int front()//访问最前面的元素\n        return z[head];\n&#125;\n\nSTL实现STL实现需要用到头文件\n#include “queue”\n\n//核心代码\n\nqueue &lt;int> q;\n\nint main()\n&#123;\n    q.push(233);//加入一个元素\n    q.push(2333);\n    q.pop();//删除最前面的元素\n    q.front();//访问最前面的元素\n    q.size();//询问队列大小\n&#125;\n栈栈这个数据结构我们可以把它想象成一个桶,我们能做的事情是向桶里加一个元素,和在桶里取出一个元素\n我们如果向栈里顺次放入1,2,3的话,那么我们最开始取出的元素为3;我们把这个性质叫做栈的先进后出性质\n代码实现手写栈\n//核心代码\nstruct stack\n&#123;\n    int size = 0;\n    int z[maxn];\n\n    void push(int x)&#123;\n        size++;\n        z[size] = x;\n    &#125;\n\n    void pop()\n        size--;\n\n    int top()//询问栈顶元素是多少\n        return z[size];\n&#125;STL实现STL实现栈需要用到#include “stack”\n\n//核心代码\n#include &lt;stack>\n\nstack &lt;int> s;\n\nint main()\n&#123;\n    s.push(233);\n    s.push(2333);\n    s.pop();\n    s.top();//询问栈顶元素\n    s.size();//栈里面有多少个元素\n&#125;堆 —— 优先队列支持的操作1.加一个数\n2.删除一个数(删掉最大的数)\n3.询问最大的数是多少\n进行上述操作的是大根堆\n与上述操作相对应的即删除和询问的数都是最小的元素,这样的数据结构称为小根堆。\n实现思路要想实现这个思路我们要先学习另外一个数据结构 ——— 二叉树\n二叉树二叉树就是每个节点都有一个左儿子和一个右儿子的数据结构\n现在有一个p节点,那么Ap节点的左儿子为A2p,右儿子为A2p+1,而且必须满足性质Ap ≥ A2p且Ap ≥ A2p+1\n所以我们能维护好Ap ≥ A2p且Ap ≥ A2p+1这个性质,最大值就可以很简单的取出来了\n在这条性质下,最大值是A1这个节点的值,即根节点的值\n代码实现手写\n\ncpp\n\n//核心代码\nstruct heap&#123;\n    int n,z[maxn];\n\n    int top()\n        return z[1];\n\n    void push(int x)&#123;\n        n++; z[n] = x;\n        int p = n;\n        while(p != 1)&#123;\n            int f = p/2;\n            if(z[f]  z[p*2]) pp == p*2+1;\n            if(z[p] \n\n\nSTL实现堆需要用到头文件include “queue”\n大根堆\n//核心代码\n#include &lt;queue>\n\npriority_queue&lt;int> heap;//大根堆\n\nint main()\n&#123;\n    heap.push(233);\n    heap.push(2333);\n    heap.pop();\n    heap.top();\n    heap.size();\n&#125;小根堆//核心代码\n#include &lt;queue>\n\npriority_queue&lt;int> heap;//小根堆\n\nint main()\n&#123;\n    heap.push(-233);\n    heap.push(-2333);\n    heap.pop();\n    heap.top();\n    heap.size();\n&#125;—-End\n其实还有一些例如循环队列 双端队列 单调队列这种在队列的基础上进行深化的数据结构本文就不提了,这些数据结构我会在进阶数据结构里面提到这些数据结构\n","slug":"基础数据结构","date":"2021-09-16T12:40:16.000Z","categories_index":"","tags_index":"知识点,数据结构,链表,栈,队列,STL,树,二叉树,堆","author_index":"TheLight"},{"id":"2205e815a910486f8a5ae632a2606305","title":"图论基础","content":"图论基础图的定义:图G是一个有序二元组(V,G),其中V称为点集(Vertices Set),E称为边集(Edges set).\n有向图:\n   \n可以从1→2，但不可以从2→1\n无向图:\n\n可以从1→2，也可以从2→1\n有向图、无向图:如果给图的每条边规定一个方向，那么得到的图称为有向图.在有向图中，与一个节点相关联的边有出边和入边之分.相反，边没有方向的图称为无向图。图的概念:度(Degree):一个顶点的度是指与该顶点相关联的边的条数，顶点v的度记作d(v)。即一个点连接了多少条边。(住：度一般是针对无向图)\n例如1这个节点的度就是d(v) = 5\n入度(In-drgree)和出度(Out-degree):对于有向图来说,一个顶点的度可细分为入度和出度。一个顶点的的入度是指与其关联的各边之中，以其为终点的边数;出度则是相对的概念，指以该顶点为起点的边数。(注：入度和出度一般针对有向图)\n例如：1节点的入度为in(v) = 3，1节点的出度为out(v) = 4;\n自环(Loop):若一条边的两个顶点为同一顶点，则此边称作自环。即一个点的起点和终点都是同一个点.\n无向图\n\n有向图\n路径(Path):\n例如:这个无向图的路径可以为1→2→3→5→1→4\n简单路径:路径上的不重复的路径。\n还是上面的图 1→2→3→5就是一个简单路径。\n环:首尾相连的路径简单环：所有的点除了出发点和结束点相同其余所有点都只会出现一次;\n\n例如:环的路径可以为1→2→3→4→5→2→1；简单环的路径可以是1→2→ 3→4→1。\n特殊的图没有环的无向图:树性质：1.连通    2.无环    3.无向n个点的树有n-1条边\n如果树的性质只满足无环和无向的话那么我们将这种图叫做森林如果树的性质只满足连通和无环那么我们可以得到有向树有向树可以分为外向树和内向树(有向树和无向树的概念都是相对于方向决定的)外向树：可以找到一个点使得所有的边都是从这个点向外走的\n内向树：可以找到一个点使得所有的边都是朝着这个点走的\n如果树的性质只满足连通和无向那么我们可以得到数的拓展图——章鱼图(章鱼图一定存在一个环)；中间有一个环，从每个点延伸出去的部分都是一颗树的图这种图我们把它叫做章鱼图(周围的树没有环)n个点的章鱼图有n条边\n树的基本定义:根，儿子，父亲，爷爷，祖先，深度,叶子节点根节点:最上面的节点。儿子节点:向下走的下一排点。父亲节点:向上走一步的点。爷爷节点：从一个点向上走两步的点。祖先：从该点开始走到根节点的所有点。深度:定义根节点的深度为1，选定的点在第几层就是深度。叶子节点:没有儿子的节点。\n例如:这棵树的根节点为1;7的儿子节点为10、11、12;7的父亲为3;7的爷爷为1;12祖先为1,3,7,12;这棵树的深度为4，这棵树的叶子节点。\n二分图性质：1.无向图        \n2.可以把所有的点分为左边和右边两部分,并且所有边都是从左边一个点连到右边一个点\n特殊的图中的二分图：树一定是二分图(将所有奇数深度的点放在左边，将所有偶数深度的点放在右边)\n二分图的判定方式：如果有长度为奇数的简单环则不是二分图，如果长有度为偶数简单环则是二分图,如果没有环则是二分图。\n二分图的判定方法: 黑白染色法 + dfs(深度优先搜索)我们可以把黑白染色法看成一个向外拓展的过程\n我们可以先把一个点标为1,那么根据二分图的性质我们只能在1这个点的周围全部标为2,再把拓展出的2周围所有的点标为1,再把拓展出的1周围所有点标为2······\n代码实现//核心代码\n    int col[maxn];//col[i] = 0 代表i点还没被分到左边\n    //col[i] = 1 代表i点分到了左边\n\n    col[1] = 1;\n    queue&lt;int> q;//队列里面存的点是那些周围点需要被标记的点\n    q.push(1);\n    while (q.size()!=0)\n    &#123;   \n        int now = q.front();\n        q.pop();\n        for(int p = first[now];p!=0;p = ed[p].next) &#123;\n            int e = ed[p].e;\n            if(col[e] == 0)&#123;\n                col[e] = 3 - col[now];\n                q.push(e);\n            &#125;\n            else &#123;\n                if(col[e] == col[now]) printf(\"No\\n\");\n            &#125;\n        &#125;\n    &#125;\n    printf(\"Yes\\n\");\n&#125;\n图的存储方法-邻接矩阵//核心代码(无边权的图)\n for(int i = 1;i &lt;= n;i++)&#123;\n        int s,e;\n        scanf(\"%d%d\",&amp;s,&amp;e);\n        z[s][e] = 1;\n        //z[e][s] = 1无向图再加上这个\n    &#125;\n\n//核心代码(有边权的图)\nfor(int i = 1;i &lt;= n;i++)&#123;\n\tint s,e,d;\n    scanf(\"%d%d%d\",&amp;s,&amp;e,&amp;d);\n    z[s][e] = d;\n\t//z[e][s] = 1无向图再加上这个\n&#125;\n优点和缺点:\n优点: 1. 好写 2.查询(i,j)复杂度O(1)\n缺点: 1.占用空间大 2.不可以处理重边\n边表\n主代码//核心代码\nconst int maxn = 1e5+10;\nconst int maxm = 2e5+10;\n\nint n,m,en,first[maxn];//n代表点数,m代表边数\n\nstruct edge&#123;\n    int e,d;//e代表这条边的终点,d代表这条边的长度\n    int next;//链表里下一条边的编号\n&#125;ed[maxm];\n\nvoid add_edge(int s,int e,int d)&#123;\n    en++;\n    ed[en].e=e;//ed[en].d=d;(如果边有权值加上这个)\n    ed[en].next = first[s];\n    first[s] = en;\n&#125;\n\nint main()&#123;\n    scanf(\"%d%d\",&amp;n,&amp;m);\n    for(int i = 1;i &lt;= m;i++)&#123;\n        int s,e,d;\n        scanf(\"%d%d%d\",&amp;s,&amp;e,&amp;d);//d为边的权值 具体使用到题目\n        add_edge(s,e,d);\n    &#125;\t\n&#125;优点和缺点:\n优点: 1.占用空间小 2.可以处理重边\n缺点: 1.不好写 2.查询(i,j)O(n)\n\n遍历边操作//核心代码\nfor(int p = first[now];p != 0;p = ed[p].next)\n    printf(\"%d %d \",now,ed[p].e);The End","slug":"图论基础","date":"2021-09-16T12:38:58.000Z","categories_index":"","tags_index":"知识点,图论","author_index":"TheLight"},{"id":"f65c2271ed43cdf14e2eea3c0c440d44","title":"前缀和与差分","content":"前缀和问题引入给定n个数a1,a2,a3,……an,有m次询问操作,给定l和r,求al ~ ar的和为多少要想求这个问题,我们需要知道a的前缀和为多少\n$我们令b_1 = a_1,b_2 = a_1 + a_2,b_3 = a_1 + a_2 + a_3,……b_k = a_1 + a_2 + a_3 + …… + a_k;则b_1 ~ b_k 就是a对应的前缀和$\n差分\n差分也十分简单\n查分的问题是给定l和r让你求出 l ~ r之间的和\n\n显而易见的是:$a_l ~ a_r的和 = a_1 ~ a_{l - 1}的和 - a_1 ~ a_r的和 = b_r - b_{l - 1}$\n#include &lt;cstdio&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdlib&gt;\n#include &lt;algorithm&gt;\n\nusing namespace std;\n\nconst int maxn &#x3D; 1e6+5;\n\nint n,m,z[maxn],sum[maxn];\n\nint main()\n&#123;\n    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);\n    for(int i &#x3D; 1;i &lt;&#x3D; n)\n        scanf(&quot;%d&quot;,&amp;z[i]);\n    for(int i &#x3D; 1;i &lt;&#x3D; n;i++)\n        sum[i] &#x3D; sum[i-1] + z[i];\n    for(int i &#x3D; 1;i &lt;&#x3D; m;i++)\n    &#123;\n        int l,r;\n        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);\n        printf(&quot;%d\\n&quot;,sum[r] - sum[r-1]);\n    &#125;\n    return 0\n&#125;\n","slug":"前缀和与差分","date":"2021-09-16T12:34:33.000Z","categories_index":"","tags_index":"知识点,前缀和,差分,小技巧","author_index":"TheLight"},{"id":"8038215b5c2b5aa82664c7d7c50d2cdc","title":"二分","content":"二分的思想\n给定一个单调的函数/数组\n给定一个值，求这个值是否存在\n或者找到这个值应当存在的位置\n\n如果想要使用二分的话,那么给定的数组/函数,必须是经过排序的,也就是sort。\n\n由于数组是有序的，我们可以认为它是单调递增的\n假设$A_i &gt; x$,则必然有$\\forall j &gt; i,A_j &lt; x$\n假设$A_j &lt; x$,则必然有$\\forall j &lt; i$,$A_j &lt; x$\n二分的原理就是每次在待定区间内选择mid\n必然可以确定一边是没有意义的。每次问题的规模就缩小$\\frac{1}{2}$\n因此时间复杂度为$O(\\log{n})$\n\n二分查找我们来看下面这么一道例题\n给定有n个元素的有序数组a，有m组询问,每次询问都会给一个数字b，询问有多少个数 $a_i \\le b$的\n分析:\n很简单可以想到遍历一遍a数组记录有多少个数$\\leq b$,但是这样做的时间复杂度显然是$O(n)$的，稍微有一点慢\n过一会我们不难发现整个数组是排好序的数组,那么我们可以充分利用这一点性质,那我们来看看怎么做呢:\n比如$a_1,a_2,a_3,……,a_n$我们要看有多少个数$\\le$b,我们可以把数组中所有$\\le$的数字记作$1$ 如果$&gt;b$的话记作$0$\n我们可以发现当我们给定b的值的时候我们可以把原数组转换成$1、1、1、1、……、0、0、0$,所有的$1$ 都在前面,所有的$0$都在后面,那么我们看有多少个$1$就可以知道有多少个数$\\le$ b了,所以我们只需要找到$0、1$的分界点即可,这种方法就叫做二分查找\n我们这里二分有两种方法一种是找最右的$1$，另外一种是找最靠左的$0$。\n方法一(找最靠右的1):\n//核心代码\nfor(int i = 1;i &lt;= m;i++)&#123;\n    int v;v = read();\n    int left = 1,right = n + 1;//代表最右边的1可能出现在z[light] ~ z[right - 1]这段区间\n    while(l + 1 != r)&#123;\n        int mid = (left + right) / 2;\n        if(z[mid] &lt;= v) left = mid;\n        else right = mid;\n    &#125;\n    printf(\"%d\\n\",left);\n&#125;\n   \n方法二(找最靠左的0):\n//核心代码\nfor(int i = 1;i &lt;= m;i++)&#123;\n    int v;v = read();\n    int left = 0,right = n;//代表最左边的0可能出现在z[light + 1] ~ z[right]这段区间\n    while(left + 1 != right)&#123;\n        int mid = (left + right) / 2;\n        if(z[mid] &lt;= v) left = mid;\n        else right = mid;\n    &#125;\n    printf(\"%d\\n\",r - 1);\n&#125;\n\n二分答案顾名思义就是对答案进行二分\n\n对于某些要求“满足某条件的最小值”类的问题，对答案进行二分，假设答案不超过mid,则问题变为“满足某条件且某值不超过mid”的判定性问题。\n常用在最大值最小化之类的问题\n在二分答案之后往往需要一个贪心策略\n\n例1:\n洛谷P2678 NOIP 2015提高组\n分析\n\n最小化: 最大跳跃的距离\n二分答案： 设置答案为mid，则问题变为：  n个石子,只能跳m次，每次最远距离不超过mid，问是否可行。  或者m个石子,每次最远距离不超过mid，问最少跳多少次(然后和m比较即可)\n贪心策略:每次跳的尽量远即可\n\n代码实现\n//完整代码\n#include &lt;bits/stdc++.h>\n\nint d,n,m,a[maxn],l,r,mid,ans;\n\nbool suv(int x)&#123;\n    int tot = 0,i = 0,now = 0;\n    while(i &lt; n + 1)&#123;\n        i++;\n        if(a[i] - a[now] &lt; x) tot++;\n        else not+=i;\n    &#125;\n    if(tot > m) return false;\n    else return true;\n&#125;\n\nint main()&#123;\n   d = read();n = read();m = read();\n   FOR(i,1,n) a[i] = read();\n   a[n+1] = d;\n   l = 1; r = d;\n   while(l &lt;= r)&#123;\n       mid = (l+r)/2;\n       if(suv(mid))&#123;\n           ans = mid;\n           l = mid+1;\n       &#125;\n       else r = mid - 1;\n   &#125;\n   printf(\"%d\",ans);\n   return 0;\n&#125;\n\n例题2进击的奶牛\n分析:\n\n题目要求让我们求出两头牛最大的最近距离，也就是让最大值最小这一问题，所以我们很容易想到二分答案\n我们可以定义一个变量来储存当前最优解。定义闭区间$[l,r]$，代表程序在这个区间内寻找答案\n令$mid = \\frac{l + r}{2}$\n若mid为解,则$ans = max(ans,mid),l = mid + 1$\n若$mid$不为解,则$r = mid + 1$.$mid$不是解,因此我们在左边寻找更优解\n\n\n重复上述过程,知道l &gt; r的时候退出循环,ans即最优解(ps:当l = r时,也必须要在区间内进行判断,因为当前还不能确定该区间内是否存在更优解)\n\n代码:\n//核心代码\nbool judge(int k)&#123;\n    int tot = 1;int num = 1;\n    FOR(i,2,n)\n    &#123;\n        if(z[i] - z[num] >= k) \n        &#123;\n            tot++;\n            num = i;\n        &#125;\n    &#125;\n    if(tot >= c) return true;\n    else return false;\n&#125;\n\nint main()&#123;\n    right = z[n] - z[1];\n    while(left &lt;= right) &#123;\n        mid = (left + right) / 2;\n        if(judge(mid))left = mid + 1;\n        else right = mid - 1;\n    &#125;\n    printf(\"%d\",left- 1);\n&#125;\n","slug":"二分","date":"2021-09-16T12:33:01.000Z","categories_index":"","tags_index":"知识点,二分查找,二分答案","author_index":"TheLight"},{"id":"eecca6179b73e75222042654664d0e18","title":"2020.11.4联考题解","content":"A(1s,512MB)题面题目背景\n因为出题人不是标题党所以就用A当题目名字了$……$\n\n题目描述\n小$m$来到了一个神奇的城市,他得到了一本书.这本书十分的神奇,它有无限的页数,每一页最多能写下$m$个单词(无论一个单词有多长).而小$m$有写日记的好习惯,他想在这本书上连续写$n$天的日记,每次写日记他都要写一些单词。现在小$m$想知道,他每天写日记需要翻多少页。(假设小$m$每次写日记都紧跟着上一次写日记的末端,即每天的日记之间没有空单词)\n输入格式\n第一行有两个整数$n$和$m$表示小$m$要连续写日记的天数以及这本书每一页能写下多少单词.\n第二行有$n$个非负整数,表示第$i$天小$m$的日记要写$a_i$个单词。\n输出格式\n输出个非负整数,表示每天需要翻页的页数。\n样例输入\n#1\n4 4\n1 1 1 1 \n#2\n4 5\n2 2 1 5\n#3\n5 7132\n192617 1145 5144 1919 8100\n样例输出\n#1\n0 0 0 1\n#2\n0 0 1 1\n#3\n27 0 0 1 1\n数据范围\n对于$40$%的数据,保证 $n ≤ 1000$对于$100$%的数据,保证 $n ≤ 10^5,m ≤ 10^9,a_i ≤ 10^9$\n分析不多解释前缀和与差分的水题\n当$\\frac{sum[i]}{m}&gt;= 0$时,我们可以输出$\\frac{sum[i]}{m}$的值并把前面的前缀和清空；如果这个条件不成立那就输出$0$,但我们可以发现这样的时间复杂度为(N),这明显不优,继续来看这道题,我们可以发现一个明显的规律\n每天需要翻页的页数 =\\frac{sum[i]}{m} -\\frac{sum[i-1]}{m}翻译成文字语言就是\n(\\frac{前i天的前缀和}{速度})-(\\frac{前i-1天的前缀和}{速度})通过这个公式我们就可以求出每天需要翻页的页数\n代码实现//完整代码\n#include &lt;bits/stdc++.h>//那么长一大串头文件不想打了直接万能头吧\n\nusing namespace std;\n\nconst int maxn = 1e5+5;\n\nint n,sum[maxn],a[maxn];\n\nint main()\n&#123;\n    cin >> n;//scanf不想打了就用cin凑合吧\n    for(int i = 1;i &lt;= n;i++) cin >> a[i];\n    for(int i = 1;i &lt;= n;i++) cout &lt;&lt;sum[i]/m-sum[i-1]/m;\n    return 0;\n&#125;\nB(1s,512MB)B题是Codeforces 1413C题的改编题\n题面题目背景\n因为出题人不是标题党所以就用B当题目名字了….\n题目描述\n有一天,小$m$来到了一个神奇的城市,这个城市里有$6$名商人,每一名商人都愿意用一个价格买小$m$的物品(对所有的物品都用这个价钱)。而小$m$一共有$m$件物品,因为他获得这些东西非常的不容易,所以他想把这$m$件商品都卖光。小$m$心中给每个物品都有一个默认的价值$v$,当他将一件价值$v$的商品卖给了一个出价为$p$的商人时,小会获得$v - p$的情绪波动值。而由于小$m$的心脏不太好,所以他希望他卖出商品得到的情绪波动值的最大值与情绪波动值的最小值的差最小,请你求出这个最小值。\n输入格式\n第一行一个正整数$m$,表示小$m$所拥有的物品的个数。\n第二行有个$6$非负整数,表示每个商人愿意出的价钱。\n第三行有$m$个非负整数,表示小$m$对他所拥有的商品价值的估计$v$。\n输出格式\n输出一个整数,表示小$m$的情绪波动值的最小值.\n样例输入\n7\n1 1 1 1 2 3\n4 13 11 12 11 13 12\n样例输出\n7\n样例解释\n小$m$将他认为价值为$4$的物品卖给商人$1$得到$3$的情绪波动值,再将其他物品都卖给最后一个商人,得到的最大的情绪波动值为$10$,这样他的情绪波动值之差为$7$,可以发现这是最小的情绪波动值之差.\n数据范围\n对于$20$%的数据,满足$n ≤ 100$\n对于$40$%的数据,满足$n ≤ 1000$\n对于$60$%的数据,满足$n ≤ 5000$\n对于$100$%的数据,满足$n ≤ 10^5,v_i ≤ 10^9$\n数据保证所有的商品估价均大于商人的出价。\n分析首先，这道题难点在于它的最大值与最小值都是会变动的。\n因此我们根据他的最大值最小值都是浮动这个特性，我们可以把它的最大/小值固定\n以固定最小值为例,我们枚举小m心里每一个物品的默认价格v,并枚举它要卖给的商人,将它此时的情绪波动值强制其作为最小值(设为minv)。\n同时,我们令其他的v不作为最小值,即其他的价格v不能小于最小值\n接下来我们只需要计算每个v的最小价格,在这些价格中取max即可。\n直接的想法是枚举其他的所有v，寻找满足$b_i - a_j \\geq minv最大的a_j$(此时$b_i - a_j$最小)。很明显，这样做是$O(n)$的。然而，我们要枚举$6n$个最小值,时间复杂度为$O(n^2)$稍微思考一下,我们发现并不是所有的v都需要枚举一遍。我们把a、b数组分别从小到大排序,并把a数组去重,那么不卖的v肯定是可以卖给a_{j-1}的v,但正好不能卖给a_j的商人中出价最大的一个。当然，如果存在v连a_1都不了，直接判定当前的最小值不合法，并枚举下一个最小值\n举个例子:a数组为$[1,3,5]$(去重之后),b数组为$[4,5,6,6,7]$,minv为3。那么，5,7是不可能取到的,因为5是可以卖给$a_1$,但不能卖给$a_2$中最大的v,7是可以卖给$a_2$但不能卖给$a_3$中最大的v。显然最大的位置在不可能取到的v中产生\n由于我们对 b 数组排过序，因此对每一个价格v，直接二分查找最大的 $b_i$ ，使 $b_i − a_j &lt; minv$ 即可。\n于是，我们只要找到这些音符即可。这些音符最多不超过6个。时间复杂度 $O(nlogn)$ 。\n最后说一下a为什么要去重,因为我们要找商人 $a_j−1$ 的v但用不了 $a_j$ 的商人的出价，如果存在重复，即 $a_j − 1 = a_j$ ，则可能这个出价为p $a_j−1$ 的商人、 $a_j$ 的都用不了，明显不符。\n代码实现#include &lt;bist/stdc++.h>\n\nusing namespace std;\n\n#define U unsigned\n#define LL long long\n#define FOR(i,a,b) for(int i = a;i &lt;= b;++i)\n#define ROF(i,a,b) for(int i = a;i >= b;--i)\n#define int LL\n\nconst int maxn = 1e5 + 5;\n\nLL a[maxn],b[maxn];\nint n;\n\ninline void check()&#123;\n    scanf(\"%lld\",&amp;n);\n    FOR(i,1,6) scanf(\"%lld\",a+i); FOR(i,1,n) scanf(\"%lld\",b+i);\n    sort(b+1,b+n+1); sort(a+1,a+7);\n    LL ans = 1e18;\n    FOR(i,1,n)&#123;\n        FOR(j,1,6)&#123;\n            int l = b[i]-a[j],r = -1e18;\n            bool flag = 1;\n            FOR(k,1,6)&#123;\n                int p = lower_bound(b+1,b+n+1,l+a[k])-b-1;\n                if(k == 1)&#123;\n                    if(p)&#123;flag = 0;break;&#125;\n                    else continue;\n                &#125;\n                if(b[p]-a[k-1] &lt; l) continue;\n                r = max(r,b[p]-a[k-1]);\n            &#125;\n            if(!flag) continue;\n            ans = min(ans,max(r,b[n]-a[6])-l);\n        &#125;\n    &#125;\n    printf(\"%lld\\n\",ans);\n\n&#125;\n\nsigned main()&#123;\n    check();\n    return 0;\n&#125;\nC(1s,512MB)C题是Atcoder AGC002 E题改编题\n题面题目背景\n因为出题人不是标题党所以就用C当题目名字了….\n题目描述\n小$m$来到了一个神奇的城市,他找到了一个知心好友小$s$,他们两个来到了一个糖果屋来$van$游戏。现在他们两个人面前有$n$堆糖果,他们两个人每次都可以选择当前糖果数最大的一堆糖果然后整堆吃掉或者把每堆糖果都吃一个。但是由于要发扬谦让的美德,所以谁先将所有糖果吃完的话,这个人将会被认为是不道德的。而小$m$和小$s$都不想当这个不道德的人,所以他们都想让对方当不道德的人。\n由于小$m$的年龄比较小,所以小$m$先开始吃,如果小$m$一定不是那个不道德的人,输出MoveToEx\nForeverGod!,如果小一定不是那个不道德的人,输出ShenSenSi ForeverGod!\n输入格式\n第一行有一个整数$n$表示糖果的堆数接下来一行有$n$个正整数$a_i$表示每一堆糖果有多少个。\n样例输出\n输出MoveToEx ForeverGod!或者ShenSenSi ForeverGod!分别代表小$m$一定获胜或者小$s$一定获胜\n样例输入\n5\n7 5 1 6 4\n样例输出\nShenSenSi 1 ForeverGod!\n数据范围\n对于$10$%的数据,保证$n ≤ 8$\n对于$30$%的数据,保证$n ≤ 100$\n对于另外$20$%的数据,保证所有$a_i = 1$\n对于$100$%的数据,保证$n ≤ 10^5,a_i ≤ 10^9$\n分析这题是一道比较经典的博弈题(虽然我在考场上没想出来正解)\n首先我们把$a_i$从大到小排序,然后画出一个高度的柱状图,就可以转化成下面这个问题：\n一开始你在(1,1)，每一次你可以从(x,y)走到(x+1,y)或者(x,y+1)。你不能走到(n+1,y)对于任意$y \\in Z$;也不能对于任意$x \\in [1,n]$走到高于$(x,a_x)$的地方。无法继续走的人判为不道德的人。\n比如下面这个例子:\n\n然后就可以非常方便的在$O(n^2)$的时间复杂度内计算出胜负关系了。\n但是没有办法通过,考虑优化:我们只关心(1,1)的胜负关系。不难发现,满足$y = x+b,b\\in Z$,的点状态是一样的。所以我们可以通过计算对角线上任意一个点的状态来得到我们想要的状态。\n再举一个例子:\n\n对于最靠近边界的点,我们发现只需要计算向上/向右到边界的距离的奇偶性，就可以知道这个点的胜负状态：如果存在一个点的距离是奇数,那么一定获胜,否则必败。\n代码实现//完整代码\n#include &lt;bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\n\ntypedef long long i64; typedef vector&lt;int> ivec; typedef vector&lt;string> svec;\n \nint n, a[101010];\n \nint main()\n&#123;\n\tscanf(\"%d\", &amp;n);\n\tfor (int i = 0; i &lt; n; ++i) scanf(\"%d\", a + i);\n\tsort(a, a + n);\n\treverse(a, a + n);\n\tfor (int i = n - 1; i >= 0; --i) &#123;\n\t\tif (a[i] - 1 >= i) &#123;\n\t\t\tint grundy = 0;\n\t\t\tint up = a[i] - 1 - i;\n\t\t\tint right = 0;\n\t\t\tfor (int j = i + 1; j &lt; n; ++j) if (a[j] - 1 >= i) ++right;\n\t\t\telse break;\n\t\t\tif (up % 2 != right % 2) grundy = 2;\n\t\t\telse grundy = up % 2;\n\t\t\tputs(grundy ? \"MoveToEx ForeverGod!\" : \"ShenSenSi ForeverGod!\");\n\t\t\treturn 0;\n\t\t&#125;\n\t&#125;\n\treturn 0;\n&#125;\nD(3s,1024MB)如果我以后线段树合并会了的话我会回来补题的 (笑题面题目背景\n因为出题人不是标题党所以就用D当题目名字了….\n题目描述\n小$m$来到了一个神奇的城市,他来到了这个城市的地铁站并看到了这个城市的地图\n这个城市一共有$n$个公园,这些公园之间由$n-1$条边相互连接,并且保证任意一对公园之间都是可以相互到达的.当几个公园的标号相邻时,这几个公园可以建立一个旅游度假区.现在小$m$想知道,在给定这些公园组成的树的树根的情况下,对于每个点为根的子树能建立几个旅游度假区。(如果几个公园之间能建立旅游度假区,那么它们一定会建立一个旅游度假区)\n输入格式\n第一行有一个正整数$T$表示数据组数\n对于每组数据,第一行有两个整数$n root$表示公园的个数以及树根的标号\n接下来$n-1$行,每行两个整数,表示边\n输出格式\n输出$T$行,每行$n$个整数,表示对于每个点为根的子树,能建立的公园数\n样例输入\n2\n7 4\n1 2\n2 4\n2 6\n1 3\n3 5\n3 7\n5 3\n3 1\n1 2\n2 4\n4 5\n样例输出\n4 2 3 1 1 1 1\n2 2 1 1 1\n数据范围\n对于$10$%的数据,满足$n \\le 12$\n对于$20$%的数据,满足$n \\le 100$\n对于$40$%的数据,满足$n \\le 1000$\n对于$70$%的数据,满足$n \\le 5000$\n对于$100$%的数据,满足$n \\le 10^5,T \\le 10$\n","slug":"2020-11-4联考题解","date":"2021-09-16T12:31:33.000Z","categories_index":"","tags_index":"题解","author_index":"TheLight"},{"id":"0366be0c07e758eb327e5de2aedcedbb","title":"topsort and 2-SAT","content":"拓扑排序\n给定一个有向图，求出一个点的序列，使得对于每条边$u \\to v$都满足$u$在$v$的前面出现。\n$1 \\to 2,1 \\to 3,2 \\to 4,3 \\to 4$,则$1,2,3,4$和$1,3,2,4$都合法。\n$1\\to 2$,$2 \\to 1$ 则无解\n\n\n有环的图一定没有拓扑排序\n结论：对有向无环图($DAG$)，一定有拓扑序\n\n$Code:$\n伪代码:\naddedge(u,v):deg[v]++\n\nqueue&lt;int> Q;\n\nfor i in graph:\n\t\t\tif deg[i] = 0;\n\t\t\t\t\t\tQ.push(i)\nwhile Q not empty:\n\t\t\tu = Q.front();\n\t\t\tQ.pop();\n\t\t\ta[++cnt] = u;\nfor(u -> v) in graph:\n\t\t\t--deg[v];\n\t\t\tif deg[v] == 0;\n\t\t\tQ.push(v);\n\n每次选一个入度为$0$的点，加到拓扑排序末尾，然后在原图里删掉这个点和它的所有初边。\n\n\n算法结束时，如果还有点没被删除，说明图中有环\n$DAG$为什么一定有拓扑序\n数学归纳法：假设点数为$n-1$的图成立，推到点数为$n$时成立。\n\n\n\n\n$Directing\\  Edges(CF1385E)$​\n\n给定一个$n$个点混合图，有$m$条有向边和$k$条无向边。给无向边定向，使它成为$DAG$，或判断无解。\n$m,m,k \\le$\n把只包含有向边的图拓扑排序\n无向边按照拓扑排序定向\n\n\n$DAG$最长链\n\n给定一个$DAG$,每个点有权值(可以是负数),问选一条链，权值和最大是多少。\n不懂\n\n\n传递闭包\n给定一个$n$个点m条边的DAG，对每个点求出它能到达多少点\n$n,m \\le 10^5$\n题解：记$S_u$为$u$能到达的点集。\n按拓扑排序倒序转移:$S_u = {u} + U_{i \\to v}S_v$\n看成二进制数,用$bitset$优化\n时间$O（\\frac{nm}{w}）$，在64位机上$w = 64$​\n\n\n$Reboot\\  from\\  Blue(lg 7480)$\n数轴上有n个加油站,第i个为于$x_i$,油价为每升c_i元\n起点坐标s，终点t，车油箱一开始是空的，且保证起点处有加油站，假设箱子容量无限大，一升油可以走距离1\n求出最小花费\n$1 \\le n \\le 10^5$,$-10^9 \\le x_i,s,t \\le 10^9,s &lt; t$\n题解:可能会往回走\n最优策略：每次刚好跑到一个油钱更小的加油站\n单调栈求左右两边第一个油钱更小的加油站，连边\n连出一个$DAG$，跑s到所有点到最段路，用它更新答案\n不用跑最短路，直接跑$dp$​\n\n\n最小拓扑序\n求$DAG$拓扑序中字典序最小的\n题解:用小根堆存入度为0的点，每次取出最小的\n\n\n树的拓扑排序个数\n给定一颗外向树,问拓扑排序个数\n$n \\le 10^6$\n题解:给每个点$i$一个标号$p_i$,表示它在拓扑序中出现的位置。\n对每条边$u \\to v$,都要满足$p_u \\le p_v$\n$dfs(x,S):$决定x子树内的标号，每个点的标号都在集合S中取。\n先给$x$标上$S$中的最小元素,并在S中删除这个元素。\n再将$S$分配给每个儿子的子树，递归调用$dfs(y,S’)$​。\n方案数:$\\prod_{x} \\frac{(size[x] - 1)!}{\\prod_{y \\in sons(x)}(size[y])!}$\n化简:$\\frac{n!}{\\prod_{x}size[x]}$​\n概率角度：点x的标号为集合中最小的数的概率为$\\frac{1}{size[x]}$​。\n\n\n拓扑序计数\n给定$n$个点$m$条边的有向图，每条边可能出现/不出现，对所有$2^m$种情况，求图中拓扑排序个数的和。\n$n \\le 20$\n不懂\n\n\n新题目\n有$n$个变量$x_1,\\cdots,x_n$，全都是正整数，给定$m$条$x_i &lt; x_j$的关系，求所有合法解中，$x$最大值的最小值\n\n\n牛x的点\n给定一个n个点m条边的DAG面对每个点x，判断它是否满足：对于图中任意一点y要么从x能到y，要么从y能到x。\n$n,m \\le 10^6$\n不懂\n\n\n庆典 ($NOI\\  2021\\  D1T3$​​)\n\n不懂\n\n\n$Insider’s \\  Infromation$​\n\n有一个排列满足m条形如$\\lceil y$出现在$x,z$之间的限制$\\rfloor$ ，现在你需要构造一个排列满足至少$\\lceil \\frac{m}{2} \\rceil$个限制\n\n\n$DAG$重链剖分\n给一个字符串S，令T是S的所有非空子序列的集合（相同的子序列会被去重）\n比如apia的子序列为{a,aa,ai,aia,ap,apa,api,apia,i,ia,p,pa,pi,pia}\n有Q个询问，回答字典序从小到大第k的子序列后p个字符，不如第10个子序列为ia\n\n\n\n\n2-SAT\n一些问题看着像2-SAT，实际上不能做\n\n最大一个数\n1个数能否超过一半\n等等\n\n\n给定n个点m条边的无向图，每个点选一个邻边，不能重复选，构造一组解\n\n可以2-SAT，但没必要\n\n\n$Radio\\  Stations$​​\n\n有 $n$ 个电台，频段在 $[l(i), r(i)]$ 之间。\n\n由你在 $[1, m]$ 中选频段 $f$。区间不包含 $f$ 的电台不能被启用。\n\n给$k$条限制，有两种：\n\n\n$1$.电台$u$和$v$至少选一个\n$2$.电台$u$和$v$不能同时选\n\n\n输出$f$和选择方案。\n\n$n, m, k &lt;= 4×10^5$​\n\n\n\n编码(loj 6036)\n\n有 $n$ 个二进制串，每个串有一位是 ?\n你要给 $?$ 填上 $0/1$，使得不存在 $i, j$ 使 $s[i]$ 是 $s[j]$ 的前缀\n\n\n\nPracticeKnights of the Round Table (POJ 2942)有 $n$ 个骑士，有 $m$ 对骑士相互憎恨。骑士可能召开圆桌会议，骑士们围绕着圆桌而坐，需要满足\n\n骑士的个数是大于 $1$ 的奇数。\n任何相邻的一对骑士都不相互憎恨。\n\n求有多少骑士不可能参加任何圆桌会议。\n$1\\le n\\le 1\\,000$$1\\le m\\le {n\\choose 2}$\nRoad Construction (POJ 3352)有一个岛上有 $n$ 个旅游景点，有 $m$ 条双向道路连接着它们。现在要修建一些额外的道路，使得任意一条道路封闭后游客都能从一个旅游景点到达任意的旅游景点。求最少需要修建的道路数量。\n$3\\le n\\le 1\\,000$$2\\le m\\le 1\\,000$\nMining Your Own Business (UVA 1108)有一张无向图，选一些点涂黑，满足任意删除一个点后（可能是被涂黑的点），每个连通分量都有至少一个黑点。求最少涂黑的点数和方案数。\n$1\\le n\\le 50\\,000$\nEquivalent Sets (HDU 3836)给定一张有向图，求至少添加多少条边能使得其强连通。\n$1\\le n\\le 20\\,000$$0\\le m\\le 50\\,000$\nPursuit For Artifacts (CF652E)给定一张简单无向连通图，边权为 $0$ 或 $1$，求从 $a$ 到 $b$ 是否存在一条边权和非 $0$ 的且不经过重复边的路径。\n$1\\le n\\le 300\\,000$$0\\le m\\le 300\\,000$\nMuseums Tour (CF1137C)一个国家有 $n$ 个城市，和 $m$ 条单向道路，每周有 $d$ 天。每个城市都有一个博物馆，每天博物馆的开放情况只和是一周中的哪一天有关，即每 $d$ 天一个循环。\n从一周中的第一天，城市 $1$ 开始，每天参观博物馆（如果开放），之后沿着一条边走到下一个城市。求无限的时间内最多能参观多少不同的博物馆。\n$1\\le n\\le 100\\,000$$0\\le m\\le 100\\,000$$0\\le d\\le 50$\nLeaders (CF97E)给定一张简单无向图，多次询问两个点之间是否存在长度为奇数的简单路径。\n$1\\le n\\le 100\\,000$$0\\le m\\le 100\\,000$$1\\le q\\le 100\\,000$\nSimple Cycles Edges (CF962F)给定一张简单无向图，求哪些边在恰好一个简单环内。\n$1\\le n\\le 100\\,000$$0\\le m\\le 100\\,000$\nCaterpillar (CF51F)定义毛毛虫是一张无环图，满足存在一条路径使得每个点离这条路径的距离不超过 $1$。给定一张无向图，现在可以每次合并两个顶点使得图变成毛毛虫。求最少需要的操作数。\n$1\\le n\\le 2000$$0\\le m\\le 10^5$\n","slug":"topsort-and-2-SAT","date":"2021-09-16T09:42:01.000Z","categories_index":"","tags_index":"知识点,图论","author_index":"TheLight"},{"id":"43339b4e6d7b5864c06090c0390d8a24","title":"图的强连通性质，桥，割点以及相关应用","content":"目录\n强连通\n\n强连通的定义\n强连通分量\nTarjan 强连通分量算法\n强连通性的应用\n\n\n边双连通\n\n边双连通分量的定义\n边双连通分量\nTarjan 边双连通分量算法\n边双连通性的应用\n\n\n点双连通\n点双连通的定义\n点双连通分量\nTarjan点双连通分量算法和圆方树\n\n\n\n\n强连通\n强连通的定义\n\n给定有向图$G = (V,E)。$\n对于$u,v \\in V$​，若$G$​中同时存在$u$​到$v$​的路径和$v$​到$u$​的路径，则称$u$​和$v$​​​强连通($strongly\\  connected$)\n对于任意的$u,v \\in V$都有$u$和$v$​强连通,则称有向图$G$强连通。\n\n\n强连通分量\n\n注意到顶点的强连通是一个等价关系。\n自反性:对任意的 $u \\in V$​，$u$和$u$强连通。\n对称性:对任意的$u,v \\in V$,若$u$和$v$强连通，则$v$和$u$​强连通。\n传递性:对于任意的$u,v,w \\in V$,若$u$和$v$强连通且$v$和$w$强连通，则$u \\to v \\to w$，$w \\to v \\to u$，因此$u$和$w$强连通\n(注意到顶点的强连通是一个等价关系)根据这个等价关系，我们可以将有向图 $G$​ 的顶点划分为若干个等价类，满足两顶点强连通 当且仅当它们在同一个等价类中。\n\n\n\n\n\n$Tarjan$ 强连通分量算法\n\n$Tarjan$ 算法会对有向图 $G$ 进行一次 $DFS$，并维护一个栈，存储那些已经被访问但未被确定 所在强连通分量的顶点。\n$DFS$ 过程中的搜索树会组成原图的一个生成森林。我们考虑强连通分量 $C$ 的第一个被访问 的顶点 $u$，则 $C$ 的所有顶点都在$u$ 在搜索树上的子树中。\n我们希望栈中的所有访问完的顶点都存在一条到达栈中之前某个顶点的路径。如果顶点 $u$ 访问完后不存在这样的路径，则说明 $u$ 以及栈中在 $u$ 之后的点组成了一个强连通分量，而 $u$ 即为这个强连通分量的根。\n算法实现:\n为了判断一个顶点是否存在到达栈中之前某个顶点的路径，我们对每个顶点维护下列变量:\n$dfn(v)$，表示 $DFS$ 到 $v$ 的时间(也就是 $v$ 是第几个访问的顶点)。\n$low(v)$​​，表示从$v$​​ 经过子树中的顶点能到达的栈中顶点中最小的 $dfn$​​。\n\n\n\n\n\n\n$Code$\n\n\nconstexpr int N = 100010;\n\n//adj[v] 存储 v 的所有后继\nstd::vector&lt;int> adj[N];\nint cur = 0;\nstack&lt;int> s;\nint dfn[N],low[N];\nbool inStack[N];\n\nvoid strongConnect(int v) &#123;\n\t//将dfn[v]和low[v] 设置为最小的还未使用的编号\n\tdfn[v] = low[v] = cur++;\n\ts.push(v);\n\tinStack[v] = true;\n\t//访问v的后继\n\tfor(int w:adj[v]) &#123;\n\t\tif(dfn[w] == -1) &#123;\n\t\t\t//w还未被访问过，对其进行递归搜索\n\t\t\tstrongConnect(w);\n\t\t\tlow[v] = min(low[v],low[w]);\n\t\t&#125;\n\t\telse if(inStack[w]) &#123;\n\t\t\t//w 在栈里，因此在当前的强连通分量内\n\t\t\t//如果w不在栈里，则说明w所在的强连通分量之前已经被确定了，因此需要忽略这条边\n\t\t\t//这里可以用low[w] 替换 dfn[w],同样是正确的\n\t\t\t//使用 dfn[w] 的原因是与另外的算法保持一致\n\t\t\tlow[v] = min(low[v],dfn[w]);\n\t\t&#125;\n\t&#125;\n\t//v是当前的强连通分量的根\n\tif(low[v] == dfn[v]) &#123;\n\t\tstd::vector&lt;int> scc;\n\t\tint w;\n\t\tdo &#123;\n\t\t\tw = s.top();\n\t\t\ts.pop();\n\t\t\tinStack[w] = false;\n\t\t\tscc.push_back(w);\n\t\t&#125; while(w != v) ;\n\t\t//scc 即为当前的强连通分量，在这里对其进行必要的操作\n\t&#125;\n&#125;\n\nvoid tarjan(int n) &#123;\n\t//顶点编号 0 ~ n-1\n\tfor(int v = 0;v &lt; n;v++) dfn[v] = -1;\n\tfor(int v = 0;v &lt; n;v++) \n\t\t\tif(dfn[v] == -1) strongConnect(v);\n&#125;\n\n强连通性的应用\n\n最优贸易\n\n$C$​ 国有$n$​个城市$m$​条单向或双向道路连接着这些城市。保证每对城市之间至多只有一条道路。 在每个城市可以以不同的价格购买或出售水晶球。商人阿龙想要从 $1$​ 号城市到达$n$​号城市，并在途中进行至多一次交易，即在某个城市买入水晶球，并在之后经过的某个城市出售。每 个城市和每条道路都可以多次经过。求出阿龙最多可以获得的利润，即售价减去买入价的差值的最大值。如果没有进行交易，则利润为$0$。\n\n$1 \\le n \\le 100000$,$1 \\le m \\le 500000$​​​\n\n在本题中，可以将双向边看成两条有向边。\n\n注意到在一个强连通分量中，可以在城市之间任意移动。我们可以将强连通分量缩成一个 点，保留其中最大和最小的价格，记为 $mx(u)$ 和 $mn(u)$。\n\n缩完点之后，原图变成了一个$DAG$(有向无环图)，我们可以拓扑排序后进行$DP$。设 $f(u)$ 是从点$1$到达点$u$​的最大利润。转移如下\nmn(u) \\gets min(mn(u),mn(v)),for each (u,v) \\in Ef(u) \\gets max(f(u), f(v)), for each (v, u) ∈ E$$​\n\n$$f (u) \\gets max(f (u), mx(u) − mn(u))\n\n\n\n\n\n","slug":"图的强连通性质，桥，割点以及相关应用","date":"2021-09-16T09:40:45.000Z","categories_index":"","tags_index":"知识点,图论,强连通分量","author_index":"TheLight"},{"id":"005d78720b9e835a238af502516610c0","title":"网络流选讲","content":"网络流选讲网络流定义\n一个有向图，存在源点$S$和汇点$T$，每条边有一个流量，求从$S$到$T$最多能经过多少流量\n$S \\in S’,T \\notin S’$​​,$E’ =  (u,v) | u \\in S’,v \\notin S $​​​​\n最大流量 = 最小割\n\nFord-Fulkerson 算法\n连上反向边之后每次dfs 贪心\n\nDinic 算法\n\n\n\n\n\n\n\n\n\n每次 bfs 先把图分层，然后在分层图上跑增广（多路增广+当前弧优化）。复杂度 $O(|V|^2 |E|)$。\n当然网络流存在最高标号预留推进（$HLPP$）等复杂度更优的做法，但是比较复杂。\n\n最大权闭合子图\n一个有向图，选择一个点就必须选择其后继点，且选择每个点有一个花费或者奖励。求总奖励最大值。\n建$s$连向所有正权点，负权点连向$t$​，假设初始全选所有正权点，减掉最小割就是答案\n\n\n\n最小费用最大流\n每条边有一个费用，每经过 1 的流量就会消耗固定的费用，求最大流时费用最小是多少。\n直接建反向边贪心即可，每次找最短的增广路。由于存在负权，复杂度为 $O(F|V||E|)$。\n\n上下界网络流\n\n\n\n\n\n\n\n\n上下界可行流\n有源汇上下界最小流\n有源汇上下界最大流\n上下界最小费用可行流\n二分图匹配\n给定一个二分图，左侧n个点右侧m个点，求能选出多少条端点不重复的边\n可以用匈牙利算法$O(|V||E|)$解决。也可以用Dinic $O(|E|\\sqrt{|V|})$​\n$n$ - |最大匹配| = |最大独立集|\n\nHall 定理\n判断一个二分图存不存在完美匹配\n内容: 二分图存在完美匹配当且仅当对于任意S，$|N(S)| \\ge |S|$($N(S)$表示从S连出的边另一端构成的点集)\n\n匈牙利算法\n每次贪心的找一条增广路，找不到就无解\n\n二分图最大权匹配KM算法例题\nlg P4001\nlg P2762\nP2763 试题库问题\nP2766 最长不下降子序列问题\nP2774 方格取数问题\n\n万能建图方法\n利用代数推倒来建图\n\n","slug":"网络流选讲","date":"2021-09-16T09:40:18.000Z","categories_index":"","tags_index":"知识点,图论,网络流","author_index":"TheLight"},{"id":"e2573f345f8e369bd93647303f895691","title":"优化技巧","content":"DP优化\n$f_i = min_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$​​\n使用单调队列优化\n\n\n$f_i = sum_{i - l &lt; j &lt; i}(f_j + p_j) + p_i$\n使用前缀和优化\n\n\n$f_i = min_{i - l &lt; j &lt; i}(f_j + p_j w_i) + p_i$\n斜率优化\n\n\n$f_i = sum_{1 &lt; j &lt; i}(f_j + q_{i-j}) + p_i$​​\n分治FFT\n\n\n$f_i = min_{A:j&lt;i,B,a_j &lt; a_i,C:b_j &lt; b_i}(f_j) + p_i$\nCDQ分治\n\n\n$f_i = min_{j&lt;i}{f_i + w(j+1,i)}$​\n决策单调性优化\n\n\n$f_{i,j} = f_{i-1}$\n线段树优化\n\n\n$WQS$二分(凸优化)\n长链剖分\n线段树合并\n矩阵优化（$DDP$）\n齐次线性递推\n$f_i = \\sum_{j = 1}^m f_{i,j} \\cdot a_j$\n\n\n生成函数优化\n\nNOI2007 货币兑换题意\n有$n$天，每天$A$的价值为$a_i,B$的价值为$b_i$\n每天你可以卖掉 $p \\%$ 的$A$ 和 $B$。也可以花费$k$天买入$A$和$B$，且$ A : B = r_i $\n$a_i,b_i,r_i$均为给定的值，$p,k$可以是任意实数。\n初始你有$S$元，问n天后的最大收益。\n$n \\leq 10^5$​\n题解\n\n首先这个题的p,k可以是任意实数，无法枚举，暴力都打不了\n很容易发现的一个性质是全买全卖存在最优方案\n所以一定是当天把东西全卖掉然后过几天把它全买了，以此类推\n设$f_i$表示第i天能得到最多的钱数，可以发现一定是由$(i-1)$推过来的\n$f_i =a_i \\cdot max_{j&lt;i}(g_j \\cdot r_j + g_j \\cdot \\frac{b_i}{a_i})$​​​​\n\nA\nB\n$C:p_j 单调增,-w_i x $凸包 二分 $O(n logn)$\n$D:p_j x , -w_ix$ CDQ/动态 凸包 $O(n logn)$​\n$f_i = min_{i - l \\le j &lt; i}(f_j + p_j w_i) + q_i$​\n长者一个长度为$n$的排列，有些位置上的数字已经确定了，剩下位置上的数字不确定。你要确定剩下位置上的数字，让得到的排列的最长上生子序列的长度尽量长。 $n \\leq 1e5$\nYet another ioi problem（弱化版）一条链长度为$L$，有$n$个位置上有村庄，你需要选定恰好$k$个位置摆放水井，使得这$n$个村庄到最近的水井的距离和最短。\n$n,k \\leq 1e5,L \\leq 1e9$ \nB输入一颗n哥节点的树，保证每个节点的度数$\\le 16$。\n定义一个路径集合$S$，我们把它称为“好的”，当且仅当这个集合内的路径覆盖了这棵树的所有边，且每条边仅被覆盖一次。\n任务一：要求一个$|S|$最小的好的路径集合（即：使路径条数最小）。输出这个$|S|$。\n任务二：在任务一对基础上（即满足是最小的好的路径集合），要使这个集合中路径长度的$max$最小（定义一颗树上路径长度为边的数量）。输出路径长度的$max$。\n任务三：求满足任务二条件的集合数量。输出$998244353$取模后的值\nCf 1416E考虑dp,f(i,j)表示当前dp到了a_i,b(2i) = j的情况下，合并之后的最小长度。转移显然：\n\nf(i,j) = [2j \\ne a_i] + min{f(i-1,a_i - j),f(i-1,k) + 1}为了方便后面的优化，我们稍微考虑一下dp的定义\n$f(i,j)$表示当前dp到了a_i，b(2i) = j的情况下，最多能使答案减少多少(答案初始为2n)。\n那么方程变为：\n\nf(i,j) = [2j = a_i] + max(f(i-1,a_i - j)+1,f(i-1,k))考虑用数据结构维护dp数组，每次有如下操作：\n1.记t为当前数组里的最大值，然后把大于等于a_i的位置全部删除。\n2.把整个数组反转（reverse）\n3.所有位置的数值和  + x\n","slug":"优化技巧","date":"2021-09-16T09:39:54.000Z","categories_index":"","tags_index":"DP,动态规划,知识点,DP优化","author_index":"TheLight"},{"id":"25ed3aa3446c2c64cf6228f9f4e4f9c4","title":"DP","content":"DPpart1.动态规划的核心概念\n状态\n转移方程\n初始化\n\n实例揭秘本质—斐波那契数列\n$众所周知 斐波那契数列的的递推式是:$ $f_i = f_{i-1} + f_{i-1}(i \\ge 2)$​\n$问题来了，如何来求$$f_n$?\n$这个时候就要用到f_i = f_{i-1} + f_{i-1}来得到他们的值，那么这个时候f_i,f_{i-1},f_{i-2}就对应$$动态规划$$里面的$$状态$\n$所谓的$状态$就指的是你要求f_n$​，$那么我们有一些中间结果来得到最后的f_n$​，$这些中间的结果，就叫做动态规划里面的$$状态$\n$这些状态之间的关键就叫$$转移方程$\n$最后一个概念$$状态的初始化$，$所谓的状态的初始化就是会存在$$部分状态无法通过转移方程$$求得，在斐波那契数列中$f_0 = 0,f_1 = 1$这个两个值是提前确定好的，如果没有这两个值，那么也不会有后面的值了$\n$所以解决一道普通的动态规划题，我们需要$$设计状态，求转移方程，初始化$$这三个步骤$\n$接下来我们来写一下斐波那契数列的代码来找一下其中的方法$\n$在斐波那契数列中我们可以找出三种方法即:$\n$用别人求自己$(由$f_{i-1} + f_{i-2} \\to f_i$​)\n$用自己求别人$$(由$f_i \\to $$\\begin{cases} f_{i+1} \\\\ f_{i+2}  \\end{cases}$​​​\n$记忆化搜索$\n\n\n\n\n$在某些题中我们只能用一种方法，因为这些题会利用这两种方法的一种性质$\n\n$Code:$\n#include &lt;bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e6+5;\n\nint n;\nint f[maxn];\nint tag[maxn];\n\n//记忆化搜索\nvoid dfs(int n) &#123;\n\tif(n &lt;= 1) return n;\n\tif(tag[n]) return f[n];\n\ttag[n] = true;//tag[n]代表f[n]有没有被算过\n\tf[n] = dfs(n-1) + dfs(n-2);\n\treturn f[n];\n&#125;\n\nint main() &#123;\n\tscanf(\"%d\",&amp;n);\n\tf[0] = 0,f[1] = 1;\n\t//用别人求自己\n\tfor(int i = 2;i &lt;= n;i++) \n\t\tf[i] = f[i-1] + f[i-2];\n\n\t//用自己求别人\n\tfor(int i = 2;i &lt;= n;i++) &#123;\n\t\tf[i+1] +=f[i];\n\t\tf[i+2] +=f[i];\n\t&#125;\n\n\t//记忆化搜索\n\tdfs(n);\n\treturn 0;\n&#125;\nProblem 1:组合数\n$组合数是指从n个东西里面选m个东西的方案数，一般写作C_n^m$\n$给定n和m，求出C_n^m的值是多少$\n$在这个状态里有两种情况$\n$即要选最后一个东西和不选最后一个东西$\n$将两种情况相加即可得到最后的结果$\n$C_n^m = C_{n-1}^{m-1} + C_{n-1}^m$\n\nProblem 2:\n$N * M的方格图，只能向右或者向下，走到右下的方案数？走到右下的最小代价？$\n$1.$$方案数：$\n$用f[i][j]代表走到(i,j)这个位置的方案数$\n$在这个问题中我们就要逐渐注意状态怎么来设计，在很多时候我们的题目要\\\\求什么我们的状态就要怎么来设计$\n\n\n$所以这个问题的转移方程就是f(i,j) = f(i-1,j) + f(i,j-1)初始化为f(i,0) = f(0,j) = 1$\n$2.$$最小代价$\n$用f[i][j]表示现在走到(i,j)所需要的最小代价$\n$所以转移方程显然是f[i][j] = min(f[i-1][j],f[i][j-1]) + w[i][j]$\n$初始化和1.同$\n\n$拓展$$如果要求不用dp，现在要求直接把走到(n,m)这个点的方案数用一个式子写出来应当是什么样？$\n$Solve$$我们思考如果要从(0,0)走到(n,m)一共有多少步，显然我们需要走n+m步才能到达(n,m)，进而看出往下应该走n步,往右应该走m步，所以，我们可以得出最后的式子为C_{n}^{n+m}$\n$Problem 3$\n$数字三角形$Luogu1216\n$给定一个三角形，让你从最顶上走到最下面$\n$问怎么走能够取得最大价值$\n\n$Solve$\n\n$设f[i][j]为走到(i,j)能取得的最大价值$\n$那么转移方程很显然是f[i][j] = max(f[i-1][j-1],f[i-1][j]) + w[i][j]$\n\nProblem 4\n$将上面的问题改成点权之和$\\% 100$之后最大    ，求最大价值$\n\n$Solve$\n\n$在这一题中，我们可以发现，按照以前的原则，\\\\题目问什么我们设什么已经不再好用了，在这题\\\\中我们如果设f(i,j)代表走到(i,j)和\\%$ $100$ $的最大值是多少的话，我们会遇到无法用f(i-1,j-1)和 f(i - 1,j)求出真正f(i,j)的值，也就是说这样记录的状态算出来的答\\\\案是错误的，所以我们不可以这么设计状态。$\n\n$这时候我们引入一个新的方法，就是题目每多一个条件，我的状态就多一个维度,\\\\所以我们设f(i,j,k)为    走到(i,j)使得点权和(k)$$\\%$ $100 = k 是否可能$\n\n$和上题一样从(i-1,j-1)或者(i-1,j)走到(i,j)$\\% 100$ $= k$\n$在走到(i,j)之前我们的k \\longleftarrow k - w_{i,j}$\n$所以我们的转移方程就是 \\\\ f[i][j][k] = f[i-1][j-1][k - w_{i,j}]\\ \\  ||\\ \\  f[i][j][k] = f[i-1][j][k - w_{i,j}]$\n\nProblem 5$1.最长上升子序列$\n\n$给n个数,a_1,a_2,\\cdots,a_n$\n$希望有 1 \\le b_1 &lt; b_2 &lt; b_3 &lt; \\cdots &lt; b_m \\le n$\n$使得a_{b_1} &lt; a_{b_2} &lt; a_{b_3} \\cdots &lt; a_{b_m}$ \n$即找到一个最长序列，使得这个数列一直在上升$\n\n$Solve$\n\n$观察目标，我们可以设f[i]代表我找出来的序列最后一个数为a_i时，序列最长能有多长$\n$考虑转移，显然我们需要考虑到a_i下一个数或者前一个数是谁，这样我们就可以得到 \\\\ f[i] = max_{i \\le j &lt; i\\ \\ \\  \\&amp;\\&amp; \\ \\ \\  a_j &lt; a_i}(f[j] + 1)$\n$这个转移的含义为:最后一位是a_i时，枚举一个j这就保证j &lt; i \\ \\ \\  \\&amp;\\&amp; \\ \\ \\ a_j &lt; a_i，满足了这两个条件，那么我们再补一个a_i就使它的长度+1，对于所有的j取一个最大值，我们就可以算出f(i)的值了，时间复杂度O(n^2)$\n$这个时间复杂度显然不优，这个时候我们可以用到数据结构优化dp来做$\n$a_1,a_2,a_3,\\cdots,a_n$，$设里面的最小值为1，最大值为m$\n我们可以建一颗$1 ~ m$的线段树\n$这个时候我们可以设a_1作为结尾的最长长度为f[1]，a_2作为结尾的最长长度为f[2]， \\\\ \\cdots,以此类推$\n$假设现在到了i,我们要算以i为结尾的最长长度，那么我们就要从a_i 到 a_{i-1}中选出a_j\\\\ ，使得a_j &lt; a_i并且这个f[j]是最大的$\n$将a_1 到 a_{i-1}存到f_1 到 f_{i-1}$\n$我现在要询问a_i的值就是在1 \\le f_i \\le a_i找到f_i的最大值$\n$这样这个问题就转化为了一个查询区间最大值的线段树，这个区间就是1$ ~ $a_i - 1$ $这个区间就是包含了所有&lt; a_i的数，也很容易得到a_i对应的为f_i+1$\n\n$2.求方案$\n\n$根据上面的问题我们再换成求最长上升子序列的方案\n\n$Solve$$所有求方案的DP基本上都是一个套路$$下面用这个题来解决求方案的问题$\n\n$对于这个问题，我们除了要记录原来题目中的状态之外，还需要设一个pre[i],\\\\ 来记录是从哪个状态转移过来的$\n$例如，pre[10] = 7代表的含义就是f[10]这个位置的状态是从f[7]转移过来的，那么我们可以接着设$\n$pre[7]=5，pre[5]=2,pre[2]=1 ，我们这样就可以倒着走遍历出来最优方案，\\\\最后的方案就是a_1,a_2,a_5,a_7,a_{10}这个序列$\n\nProblem 6$滑雪$\n\n$n行m列的图$\n$每个格子有高度$\n$可以滑向周围四个比自己矮的格子$\n$最多能划多远$\n\n$Solve$\n$这个问题和迷宫很不一样，迷宫是给定了起点，而这个题目是让你自己选择起点$$通过观察我们可以发现，我们可以将原图按照从大到小或者从小到大排一遍序$$然后我设f(r)为以r为重点最远可以走多远$$现在，我们把问题转化成了一个最长下降子序列，现在转移方程就很显然了$f[r] = max_{1 \\le k \nProblem 7$乌龟棋$\n\n$长度为n的格子有权值$\n$m张牌，上面有1-4中其中一个数$\n$使用一张牌往前走几步$\n$最大化经过的路径权值和$\n\n$Solve$\n\n$我们设f[i]为走到了i这个位置,但是我们会发现,无法判断牌被用了多少张,\\\\也就是说会出现越界,所以我们需要再多加几维状态：设f[i][a][b][c][d]为走\\\\到i这个位置时，1牌被用了a张，2牌被用了b张，3牌被用了c张，4牌被用了d张$\n$思考复杂度，这个复杂度是O(nm_1m_2m_3m_4) \\approx O(n^5)显然是过不了的$\n$在Problem5中我们讲解了数据结构优化dp,在这里我们讲解另外一种优\\\\化dp的方式$$冗余状态优化$\n$观察状态设计,我们通过简单的推出一个式子$$$i = a+2b+3c+4d$$$所以这五维状态我们任意删除一个状态即可,这样我们就把时间复杂度\\\\由O(n^5)优化到了O(m^4)了$\n\n区间DP\n$以区间作为dp的状态，每次区间[l,r]$\n$即设f(i,j)表示区间[i，r]的最优解$\n\n$Problem1$\n$合并石子$\n\n$有n堆石子,a_1,a_2,a_3,\\cdots,a_n$\n$需要做n-1次操作，每次操作需要合并相邻两对石子$\n$例如,合并a_2和a_3就是a_2 + a_3然后就变成了n-1堆石子a_1,a_2+a_3,\\cdots,a_n，且合并\\\\这两堆石子的代价为a_2+a_3$\n$现在希望你合并出来a_1+a_2+a_3+\\cdots+a_n，并且最小代价是多少$\n\n$Solve$\n\n$这道题是典型的区间dp题,当你看到有相邻的操作的时候，我们首先就要考虑区间dp。$\n$首先很容易想到的一个性质就是，如果a_l,a_r被合并了，那么a_l,a_{l+1},\\cdots,a_{r-1},a_r \\\\都被合并$\n$想到了如下性质之后我们来讲一下关于区间dp的三要素$\n$状态：一般设计成f[l][r] 代表把第l$ ~ $r 合并为\\cdots$\n$转移：思考f[l][r]怎么求，在合并l$ ~ $r的前一次操作是把l$ ~ $k$和$k+1$ ~ $r的合并成一堆$，$那么合并成这两堆石子的代价分别是，f[l][k]和f[k+1][r]，\\\\所以这个转移方程是$ f[l][r] = min_{l \\le k \\le r}(f[l][r],f[l][k] + f[k+1][r] + sum[r] - sum[l-1])$$\n$初始化：首先肯定要让i \\rightarrow i 花费的代价为0，故f[i][i] = 0$\n\n\n\n$Problem2$\n\n$n个矩阵$\n$m_1:a_1 \\times a_2，m_2:a_2 \\times a_3，m_3: a_3 \\times a_4,\\cdots,m_n:a_n \\times a_{n+1}$\n$把n个矩阵乘起来，可以进行结合律，计算m_2和m_3这两个矩阵的代价是a_2 \\times a_3 \\times a_4，随后这两个矩阵变成(m_2 \\times m_3):a_2 \\times a_4$\n$现在的问题是，把这些矩阵加一些括号，使这些矩阵代价最小$\n\n$Solve$\n\n$基于上一题的思想，我们可以设f[l][r]为将m_l$ ~ $m_r这些矩阵乘起来所需要的最小代价$\n$枚举一个中间的断点k，把a_l$ ~ $a_k和a_{k+1}$ ~ $a_r分别算出，最后把这两个矩阵乘起来即可$\n$所以这个转移方程就是$f[l][r] = min_{l \\le k \n$所以这一题我们也用区间dp搞定了$\n\n$Problem3$\n\n$给出一个的只有()[]四种括号组成的字符串$\n$求出最多能够选出多少个括号满足完全匹配$\n\n$Solve$\n\n$这个题的转移方法和上面的不太一样，我们设f[l][r]代表从l - r最多能取出多少个括号进行匹配$\n$思考f[l][r]和f[l+1][r]的关系,例如f[l+1][r]我们可以取10个括号进行匹配，那么f[l][r]也可以取十个括号$\n$同理，如果f[l][r-1]取了12个括号，那f[l][r]也可以取12个括号$\n$所以f[l][r] = max(f[l][r] || f[l][r-1])$\n$思考还有没有其他的情况，显然还有一种情况是如果l - r为:(()),1-4这四个括号可以选4个括号,因为除了在l - r-1和l+1 - r这两个区间内部以外，还有一种方案是从l+1 - r-1，在l和r匹配相同的括号，再在l+1 - r-1中匹配括号$\n$也就是说f[l][r] = max(f[l][r] || f[l][r-1] || f[l+1][r-1]+2)最后一维代表l和r能够匹配$\n\n树形DP\n以树上的节点作为dp状态，记 d(u)表示u的整颗子树的的信息，从儿子的状态转移过来\n\n状压DP数位DP$\\le n$的满足条件的数字个数\n$\\le 10^n$ 的满足条件的数字个数​\n有不超过$n$个十进制位\n$d_{i,j}$表示从高到低的前i位已经选择完，且最低的位为$j$的方案数\n转移:枚举$i+1$位填的数字$k$，要求，$|j-k|\\ge 2$，从$d(i,j)$转移到$d(i+1,k)$​​​\nP2235$f(n) = \\begin{cases} f(1) = 1 \\\\ f(3) = 3 \\\\ f(2n) = f(n) \\\\ f(4n+1) = 2f(2n+1) - f(n)\\\\f(4n + 3) = 3 f(2n+1) - 2f(n) \\end{cases}$\n\n这个函数代表的意思是把n的二进制串翻转\n\n所以，很容易想到数位$dp$\n\n设$d(i,c1,c2)$​表示考虑j前i为和后i位，c1\n枚举回文数的第i+1位是k，转移到$d(i+1,c1’,c2’)$\n\nP3281The Last\n求$\\sum_{i = l}^r\\lgroup ^{a+i} _b  \\rgroup c^i \\mod p$​\n\n$p \\le 1e5 , c &lt; p, l, r, a, b \\le 1e18$\n\n$p$为质数\n\n","slug":"DP","date":"2021-09-16T09:38:51.000Z","categories_index":"","tags_index":"DP,动态规划,知识点","author_index":"TheLight"},{"id":"ec60c99e46e2ba013a49cda28261b89b","title":"生成函数的运算与组合数计数问题.md","content":"生成函数的运算与组合数计数问题摘要\n​    本文介绍了处理形式幂级数的一些高效算法，并在生成函数的运算过程中加以应用，从而解决一系列组合计数问题。\n目录$1$.引言\n$2$.多项式与形式幂级数\n​    $2.1$ 多项式\n​    $2.2$ 多项式的基本运算\n​    $2.3$ 形式幂级数\n$3$.组合计数问题\n​    $3.1$ 组合对象\n​    $3.2$ 普通生成函数\n​    $3.3$ 指数生成函数\n$4$.乘法逆元\n$5$.乘法逆元的应用\n$6$. 对数与指数运算\n​    $6.1$ 复合运算\n​    $6.2$ 形式导数\n​    $6.3$​ 对数函数与指数函数\n\n​            $6.3.1$ 对数函数的计算\n​            $6.3.2$ 指数函数的计算\n​    $6.4$ 牛顿迭代法\n​    $6.5$ $k$次幂的计算\n$7$ 集合的计数\n​    $7.1$ 有标号集合的计数\n​    $7.2$ 无标号集合的计数\n$8$ 环的计数\n​    $8.1$ 有标号环的计数\n​    $8.2$ 无标号环的计数\n$9$ 复合运算\n​    $9.1$ 复合与复合逆\n​    $9.2$ $Lagrange$反演\n$10$ 二元生成函数\n$11$ 结语\n\n$1$​ 引言​    组合计数问题是信息学竞赛中常见的一类问题，而生成函数往往是解决这类问题的重要工具。近年来，信息学竞赛中出现了这样一类计数问题，不仅需要选手根据题意对生成函数进行分析与推导，还要求使用高效的算法完成各类多项式运算，才能优化求解的时间复杂度。本文将对这一类问题进行进一步分析与总结。\n​    本文第2，3节回顾了一些需要用到的基本知识。其中第2节提到了几种熟知的多项式乘法算法，以及算法实现时需要注意的地方；第3节引入了组合对象的生成函数的概念，并分析了生成函数加法、乘法的组合意义。\n​    第4节介绍了求解形式幂级数乘法逆元的牛顿迭代法，这一算法是后文许多算法的基础。第5节中的例题对该算法进行了简单应用。\n​    第6节介绍了形式幂级数的对数，指数函数的求解算法。\n​    第7，8节分析了集合、环这两类常见组合模型的计数方法，并对第6节中的算法进行了简单应用。\n​    第9节简单介绍与复合运算相关的算法和定理。\n​    第10节介绍了运用二元生成函数解决问题的技巧。\n$2$ 多项式与形式幂级数$2.1$ 多项式​        多项式是我们熟知的数学概念。一个关于x的多项式可以写成 \n\nA(x) = \\sum_{i = 0}^{n-1} a_ix^i的形式，其中系数$a_i$均为某个环$R$中$^①$​的元素。这些多项式组成多项式环$R[x]$。\n​        非零多项式$A(x)$的次数定义为其最高次项的系数，记为$deg A(x)$。\n$2.2$ 多项式的基本运算​        设参与运算的多项式中最高次数为$n$。那么多项式的加法、减法显然可以在$O(n)$时间内计算。\n\n①一般指可交换环，可以是复数域$C$、实数域$R$、整数环$Z$、剩余类环$Z/nZ$等。\n\n​        我们关心的是两个多项式的乘积。朴素的计算方法需要$O(n^2)$时间，并不够优秀。\n​        一中优化方法是分治乘法$^②$，它的原理是利用\n\n(Ax^m + B)(Cx^m + D) \\\\\n\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =ACx^{2m} + ((A + B)(C + D) - AC - BD)x^m + BD减少乘法次数进行递归。复杂度为$O(n^{\\log_23}) = O(n^{1.585})$。\n​        分治乘法的劣势在于复杂度较高，但它不涉及除法，所以对环$R$没有特别的要求。\n​        此外，当运算在模2意义下进行时，我们也可以利用位运算加速，使得算法常数减小到原来的$1/32$。\n​        另一种做法是$FFT^③$​。它利用单位根的性质，实现了多项式的系数与点值表示之间的快速转化。时间复杂度是$O(n logn)$。\n​        为了使用$FFT$，$R$需具有$2^k$次单位根($2^k \\ge 2n$)，且存在2的乘法逆元。当系数在复数域内时，单位根总能找到，但计算时容易出现精度问题。\n​        需要注意到的是，信息学竞赛中涉及的计数问题往往要求答案模一个大质数$p$(如$1e9+7$或$998244353 = 7 \\times 17 \\times 2^{23} +1$等等)后输出。这样的好处包括：每次算术运算的时间可以视作$O(1)$，不存在精度问题，且大多数情况可以支持除法(只要在问题规模范围内，除数都远小于$p$，存在乘法逆元)。因此本文中假设所有运算都在$F_p$下进行。\n​        在模$p$​意义下进行$FFT$​时，若满足$2^k|\\varphi(p) = p -1$​，则可取$p$​的原根$g$​，并用$g^{\\frac{p-1}{2^k}}$​作为单位根；否则，将系数视作$Z$​的元素进行运算后再对$p$​取模。这时，相乘得到的系数大小不超过$np^2$​​，只要取若干个便于$FFT$​的大质数分别进行运算，再用中国剩余定理（$CRT$）还原系数即可。\n$2.3$ 形式幂级数​        一个多项式仅有有限项的系数是非零的。若去掉这一限制，可将其推广为形式幂级数\n\nA(x) = \\sum_{i \\ge 0} a_ix_i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2,2)————————————————————\n②详见http://en.wikipedia.org/wiki/Karatsuba_algorithm\n③详见http://en.wikipedia.org/wiki/Discrete_Fourier_transform\n\n它们组成了形式幂级数中环$R[[x]]$。\n​        此定义中，$x$仅作为一个符号，而不用具体的数值带入运算，故不必考虑与幂级数敛散性有关的问题。\n​        我们用$[x^n]A(x)$表示$A(x)$的$n$次项系数$a_n$。\n​        形式幂级数的加减法与乘法也可与多项式运算类似定义：\n\nA(x) = \\sum_{i \\ge 0} a_ix^i，B(x) = \\sum_{i \\ge 0} b_ix^i，\\ \\ \\ \\ \\ \\ \\ (2.3) \\\\\nA(x) \\pm B(x) = \\sum_{i \\ge 0} (a_i \\pm b_i)x^i，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\  \\ \\ (2.4) \\\\\nA(x)B(x) = \\sum_{k \\ge 0} (\\sum_{i+j = k}a_ib_j)x^k \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (2.5)​        实际运算时，通常只需保留次数不超过$n - 1$的项进行计算，并将多余的项舍去(即在模$x^n$意义下计算)。因此加减法的复杂度为$O(n)$，乘法的复杂度为$O(nlogn)$。\n$3$组合计数问题$3.1$ 组合对象​        组合计数问题是一类常见的问题。这类问题中一般定义了一类组合对象$A$​，它可能是满足某一性质的树、图、串等对象的集合；其中每个对象$a \\in A$​都被定义了大小$size(a)\\in n$​的对象$a$的数量是有限的，计作$A_n$。我们的任务通常为求出$A_n$的数值。\n​        根据不同的问题要求，组合对象可以分为有标号和无标号两类。下面简单以无向图为样例解释它们的区别：\n​        n个点的标号图中，每个顶点都被赋予了$1,2,\\cdots，n$中的唯一标号；然而在无标号图中，每个顶点的地位是没有区别的。如图所示，$n = 3$时，无标号的简单无向图共有四种，而有标号的简单无向图有$8$种。\n\n\n\n$3.2$ 普通生成函数​        数列$A_0,A_1,\\cdots$的普通生成函数（$Ordinary\\ Generating\\ Function，OGF$）定义为形式幂级数\n\nA(x) = \\sum_{i \\ge 0} A_ix^i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.1)​        $A$是一类无标号对象，则$A$的普通生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的普通生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        对于两类无标号对象$A,B$，定义一类新的对象$C = A \\cup B$，若$A，B$交集为空，则$C$的生成函数即为\n\nC(x) = A(x) + B(x).        \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.2)​        再来考虑$A,B$的笛卡尔积$D = A \\times B$，其中$D$的每个元素$d$都是一个二元组$(a,b)$，其中$a \\in A,b \\in B$，并定义$size(d) = size(a) + size(b)$。则有\n\nD_k = \\sum_{i + j = k}A_iB_j，\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3,3)于是$D$的$OGF$即为\n\nD(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.4)这一操作实现了$A$中元素和$B$中元素的拼接。\n$3.3$ 指数生成函数​        数列$A_0，A_1,\\cdots$的指数生成函数（ $Exponential\\ Generating Function，EGF$​）定义为形式幂级数\n\nA(x) = \\sum_{i \\ge 0} A_i\\frac{x_i}    {i!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.5)\n指数生成函数在处理有标号问题时更加便捷。对于一类有符号对象$A$，$A$的指数生成函数$A(x)$定义为数列$A_0，A_1，\\cdots$的指数生成函数，其中$A_n$满足$size(a) = n$的对象$a \\in A$的数量。\n​        给定两类有标号对象$A,B$，对于它们的并集$C = A \\cup B$，同样有\n\nC(x) = A(x) + B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.6)​        现在考虑有标号对象的拼接。给定两个对象$a,b$​，设$size(a) = n$​ ，$size(b) = m$​，他们分别带有$1,2,\\cdots,n$​和$1,2,\\cdots,m$​的标号。为将$a,b$​拼接得到$c$​，需给$c$​分配$1,2,\\cdots,n+m$​的标号。规定重新分配时需要保持标号的原有相对顺序，则有\n\n\\binom{n+m}{n} = \\frac{(n+m)!}{n!m!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.7)种方法\n​        因此。若将两类带标号对象$A,B$拼接得到$D$，则有\n\nD_k = \\sum_{i + j = k} A_iB_j \\frac{k!}{i!j!}\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.8)从而$D$的$EGF$也具有\n\nD(x) = A(x)B(x)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (3.9)的形式。\n$4$ 乘法逆元​        当$A(x)B(x) = 1$时，称$A(x)，B(x)$互为乘法逆元，可以写作$A(x) = B(x)^{-1}   = 1 / B(x)$。除以一个形式幂级数，就相当于乘上它的乘法逆元。\n​        例如，\n\n\\frac{1}{1 - x} = 1 + x + x^2 + x^3 + \\cdots.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.1)根据这一等式可得，若数列$a_0,a_1,\\cdots$的普通生成函数为$A(x)$，令$s_n = \\sum_{i = 0}^{n}a_i$，那么$s_0,s_1,\\cdots$的普通生成函数为$A(x)/(1-x)$。\n​        再结合二项式系数的递推性质，可得\n\n\\frac{1}{(1-x)^{n+1}} = \\sum_{i \\ge 0} \\binom{n+i}{n}x^i \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.2)\n​        接下来介绍，在给定$A(x)$时，如何求出$A(x)$的乘法逆元$B(x)$。\n​        可以证明，$A(x)$存在乘法逆元的充要条件是$A(x)$的常数项存在乘法逆元。必要性由$([x^0]A(x))([x^0]B(x)) = 1$​可得。而当$A(x)$的常数项可逆时，即可根据乘法的定义($2.5$)按顺序求出$[x^1]B(x),[x^2]B(x),\\cdots$的值，于是此时乘法逆元存在且唯一。同时，我们得到了一个求出乘法逆元前$n$项的$O(n^2)$朴素算法。\n​        下面介绍一个用$O(nlogn)$时间计算乘法逆元的算法，它的本质是牛顿迭代法。\n​        首先求出$A(x)$的常数项的逆元$b$，并令$B(x)$的初始值为$b$。\n​        假设已求满足\n\nA(x)B(x) \\equiv 1\\pmod  {x^n} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.3)的$B(x)$，则\n\nA(x)B(x) - 0 \\equiv 0 \\pmod {x^n}， \\\\\n(A(x)B(x) - 1)^2 \\equiv 0 \\pmod {x^{2n}}， \\\\\nA(x)(2B(x) - B(x)^2 A(x)) \\equiv 1 \\pmod {x^{2n}}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (4.4)我们用$o(n logn)$时间计算出$2B(x) - B(x)^2A(x)$，并将它赋值给$B(x)$进行下一轮迭代。每迭代一次，$B(x)$的有效项数$n$都会增加一倍。于是该算法的时间复杂度为\n\nT(n) = T(n/2) + O(n logn) = O(nlogn).$5$  乘法逆元的应用例题1(序列计数).你有若干种不同颜色的骨牌，其中大小为$1 \\times i$的骨牌共有$a_i$种。每种骨牌都可以无限量使用。用骨牌不重叠地铺满一排$1 \\times n$的方格，共有几种方法？($a_i,n \\le 10^5$​)\n​        我们枚举使用的骨牌数量$k$。设$A(x) = \\sum_{i \\ge 0}a_ix_i$，则根据生成函数的乘法的意义，容易知道此时的答案为$[x^n]A(x)^k$。所以总方法数目为\n\n[x^n]\\sum_{k \\ge 0} A(x) = [x^n]\\frac{1}{1 - A(x)}. \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.1)于是只需计算$1 - A(x)$的乘法逆元即可，时间复杂度$O(n logn)$。    \n\n​        一般地，对于这一类组合对象$A$，由$A$的元素组成的序列定义一类新的组合对象$B$，则$B$的生成函数为\n\nB(x) = \\frac{1}{1 - A(x)}.\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.2)这一结论对于无标号$(OGF)$、有标号$(EGF)$的情况都成立。\n例题2(预处理$Bernoulli$).\n对于所有$0 \\le i \\le n-1$求出$B_i$。($n \\le 10^5$)\n$Bernoulli数B_0,B_1,\\cdots的指数生成函数为$\n$B(x) = \\sum_{i \\ge 0} B_i\\frac{x^i}{i!} \\\\=\\frac{x}{e^x -1} \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ (5.3) \\\\=(\\sum_{i \\ge 0}\\frac{x^i}{(i+1)!})^{-1}.$这样，只要求一次乘法逆元即可。\n例题3.$字符集大小为m。给定一个长度为k的字符串s，求出所有长为n的串中，不包含子串s\\\\的共有几个$\n$\\ \\ 假定串的下标都从1开始$\n$\\ \\ 考虑DP，用f_i表示有多少种方法填前i个字符，使得第一次匹配上串s的位置是$ $[i-k+1,i]。当i &lt; k时,f_i = 0;当i \\ge k$，\nf_i = m^{i-k} - \\sum_{0 \\le j \\le i - k}f_im^{i-k-j} - \\sum_{d > 0,d \\in C} f_{i-d}，$其中集合C定义为{d \\ge 0 | s[d+1,k] = s[1,k-d]}。$\n$这个DP方程的含义是，末尾k的字符与串s相同，前i-k位字符可以任意确定，但为了保证i - k + 1是第一次匹配上的位置，需要从中减去之前已经匹配过的情况。减去的第一项是这次匹配与上一次没有重叠的情况，第二项是与上次出现重叠的情况，为此需要先用KMP算法求出C的集合。$\n$为了优化这个DP，考虑f的生成函数f(x) = \\sum_{i \\ge 0} f_i x^i。令C(x) = \\sum_{d \\in C^{x^d}}，则可由DP方程写出$\n$f(x) = \\frac{x^k}{1 - mx} - \\frac{x^k f(x)}{1 - mx} - f(x)(c(x) - 1)，$\n\n$定义见$http://en.wikipedia.org/wiki/Bernoulli%5fnumber\n\n","slug":"生成函数的运算与组合数计数问题","date":"2021-09-16T09:32:38.000Z","categories_index":"","tags_index":"知识点,数学,生成函数","author_index":"TheLight"}]